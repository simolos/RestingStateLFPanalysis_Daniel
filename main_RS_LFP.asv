% Pipeline for the analysis of LFP from invasive recordings during  
% performance of Effort Based Decision Making task

% First use: 
% 1) define paths in the function define_general_path.m 
% 2) if needed, modify folder names in define_run_path.m (only in the specific "operator" section)
% 3) in the "Init" section:
%       - define path for scripts/functions/toolboxes
%       - define operator and machine in use
%       - subject category and id
%       - run number and run name
% 4) in the "Define phases of interest" section: change boundaries (more details in the section, around line 206
% 5) run the "Main loop" section
% 6) run the section "Create a single table including all run"



% Updated by DB on 29/09/2025

 
clear all; clc; warning off
close all;


%% Split behavioral file in two 
% (useful in case of lost connection during the recording --> we have two 
% separate LFP recording for one block!

% trial_idx_split = [1 44; 44 64];
% split_behavioral_file(trial_idx_split)

%% Init


flag_operator = 'Daniel'; % 'Simona' or 'Valeria'
flag_lab_pc = 0;

SubjCat = 'PD_TI'; % 'PD' or 'OCD'or 'PD_TI'
SubjId = 'S1_'; % 'S1_' or 'S2_'

% Data details
% OCD1: 
% AM_OFF Blocks: [6 7]       with labels {'B1','B2'}
% AM_ON Blocks: [10 11]      with labels {'B1','B2'}
% PM_ON Blocks: [4 5]        with labels {'B1','B2'}
% PM_OFF Blocks: [81 82 9]   with labels {'B1','B1','B2'}
%
% OCD2: 
% AM_OFF Blocks: [8 9]       with labels {'B1','B2'}                       EffProd: [5]
% AM_ON Blocks: [12 13]      with labels {'B1','B2'}                       EffProd: []
% PM_ON Blocks: [17 18]      with labels {'B1','B2'}                       EffProd: []
% PM_OFF Blocks: [21 22]     with labels {'B1','B2'}                       EffProd: []
%
% PD2 (146)
% Blocks: [7 8 9]  with labels {'B1', 'B2', 'B3'}                          EPfam: [5 10]  with labels {'EffProd', 'EffProd2'}
%
% PD3 (147)
% Blocks: [8 9 10]  with labels {'B1', 'B2', 'B3'}                         EPfam: [6]  with labels {'EffProd'}     DMfam: [7]  with labels {'Fam'}
%
%
% PD_TI1
% Blocks: [6 7 8 9 11 12]  with labels {'B1', 'B2', 'B3', 'B4', 'B5', 'B6'}                  EPfam: []  with labels {''}     DMfam: []  with labels {''}
% Blocks: [10]  with labels {'FCRT'}                                                         EPfam: []  with labels {''}     DMfam: []  with labels {''}
% Resting-state rec: [13 14 15 16 17] with labels {'RS1', 'RS2', 'RS3', 'RS4', 'RS5'}  

run = {13 14 15 16}; %  5 6 20
run_name= {'RS1', 'RS2', 'RS3', 'RS4'}; % OCD1: {'B1','B1','B2'};  'EffProd1' 'EffProd2' 'EffProd'

path = define_general_path(flag_operator, flag_lab_pc, SubjId, SubjCat);


%% Main loop
for r = 3:3%length(run)

    Run = run{r};
    disp(num2str(Run))

    [behav_data_folder, tag, trig_name, data_folder, code_behavfilename] = define_run_path(flag_operator, flag_lab_pc, SubjId, SubjCat, Run, run_name{r});

    % loading data
    trigger_filename =[trig_name,num2str(Run),'.mat'];
    load(fullfile(path,data_folder, ['LFP_rec',num2str(Run)]))
    load(fullfile(path,data_folder,['EMG_rec',num2str(Run)]))
    EMG_run{r} = EMG;
    LFP_run{r} = LFP;
    load(fullfile(path,'Triggers',trigger_filename)) % contains TriggerInfo matrix


    % behavioral data
    % Get a list of all files in the folder
    if flag_lab_pc == 1
        fileList = dir(fullfile(path,behav_data_folder));
    else
        fileList = dir(strrep(fullfile(path,behav_data_folder), '\', '/'));
    end

    % Extract the names of the files 
    fileNames = {fileList(~[fileList.isdir]).name};
    idx_behavfilename = find(contains(fileNames, code_behavfilename));


    behav_filename = fileNames{idx_behavfilename};

    if flag_lab_pc == 1
        behav = load(fullfile(path,behav_data_folder,behav_filename));
    else
        behav = load(strrep(fullfile(path,behav_data_folder,behav_filename), '\', '/'));
    end
    behav_run{r} = behav;

    Trig{r} = TriggerInfo;
    %% --- Handling behavioral exception and/or exclude some trials 
    % TO BE IMPLEMENTED 

    TableBehavior{r} = get_behavioral_table(behav, tag);

    disp('loaded')

    %% --- Plot aligned
    if( max(ismember(EMG.channelNames,'trig_A' ))==1 )
        idx_trig = find( strcmpi( EMG.channelNames,'trig_A' ));
    elseif ( max(ismember(EMG.channelNames,'Trig_A' ))==1 )
        idx_trig = find( strcmpi( EMG.channelNames,'Trig_A' ));
    end

    % check for NaN value
    NaNidx = find(isnan(LFP.data(:,1)));
    if ~isempty(NaNidx) 
        disp('Warning NaN values detected')
        % interpolation
        valid_idx = ~isnan(LFP.data(:,2));
        LFP.data(:,1)= interp1(LFP.time(valid_idx),LFP.data(valid_idx,1),LFP.time, 'pchip');
        LFP.data(:,2)= interp1(LFP.time(valid_idx),LFP.data(valid_idx,2),LFP.time, 'pchip');
    end

    %figure(100+r); clf
    ax(1) = subplot(2,1,1);
    plot(LFP.time, LFP.data(:,2)); hold on; grid on %ch2 microV 
    plot(LFP.time, LFP.data(:,1)); hold on; grid on %ch1 microV
    title('LFP','fontsize',16)
    xlim([LFP.time(1),LFP.time(end)])

    ax(2) = subplot(2,1,2);
    plot(EMG.time , EMG.data(:,idx_trig)*10./ std(EMG.data(:,idx_trig)) + 10); grid on; hold on 
    plot(EMG.time , EMG.data(:,1)./ std(EMG.data(:,1)) - 10 ); 
    plot(EMG.time , EMG.data(:,2)./ std(EMG.data(:,2)) - 5); 
    xlim([EMG.time(1),EMG.time(end)])

    plot(EMG.time, Trig{r}, 'k','linewidth',3) % Task-related triggers packed--> marker values
    set(gca,'ytick',[-10,-5,20],'yticklabel',EMG.channelNames)
    legend('','','','Marker value')
    % set(gcf, 'Position', get(0, 'Screensize'));

    linkaxes(ax,'x')    

    figure
    chNum_2plot = 1; % first channel: ZERO_TWO_LEFT
    sig4spec = LFP.data(:,chNum_2plot);
    sigName = LFP.channel_names(chNum_2plot);

    % SPECTROGRAM PARAMS
    fmin            = 5;   % min frequency
    fmax            = 130;  % max frequency (120)
    window_size     = 0.5; %0.5;  % window size for FFT in s
    shift_inc       = 50;  % shift increment in ms
    delta_f         = 1;   % frequency increment (in Hz)
    n_taper         = 3;   % number of tapers (integer >=1)

    t_par.Fs        = LFP.Fs;
    t_par.tapers    = [(n_taper+1)/2 n_taper];
    t_par.fpass     = [fmin fmax];
    t_par.pad       = nextpow2(2^nextpow2(1/window_size)/delta_f);

    subplot(2,1,1)
    [P,T,F] = mtspecgramc(sig4spec,[window_size,shift_inc/1000],t_par);
    P       = P';
    N_win   = window_size*LFP.Fs;
    P       = 2*LFP.Fs/N_win * P;  % P is now in mV^2/Hz
    T =  LFP.time(1)+T; % translation according to LFP time

    %P = ( P )./median(P,2);
    %P = zscore(P,0,2);

    ax(2) = subplot(2,1,1);
    imagesc(T,F,10*log(P)); hold on;
    axis xy; ylabel('Frequency (Hz)'); title(sigName,'fontsize',13,'interpreter','none')
    set(gca,'ylim',[5 130]); caxis([-35 5])
    plot([0 LFP.time(end)],[20 20],'w--')
    plot([0 LFP.time(end)],[30 30],'w--')
    pause(1)

    chNum_2plot = 2; % second channel: ZERO_TWO_RIGHT
    sig4spec = LFP.data(:,chNum_2plot);
    sigName = LFP.channel_names(chNum_2plot);

    subplot(2,1,2)
    [P,T,F] = mtspecgramc(sig4spec,[window_size,shift_inc/1000],t_par);
    P       = P';
    N_win   = window_size*LFP.Fs;
    P       = 2*LFP.Fs/N_win * P;  % P is now in mV^2/Hz
    T =  LFP.time(1)+T; % translation according to LFP time

    % P = ( P )./median(P,2);
    % P = zscore(P,0,2);

    ax(2) = subplot(2,1,2);
    imagesc(T,F,10*log(P)); hold on;
    axis xy; ylabel('Frequency (Hz)'); title(sigName,'fontsize',13,'interpreter','none')
    set(gca,'ylim',[5 130]); caxis([-35 5])
    plot([0 LFP.time(end)],[20 20],'w--')
    plot([0 LFP.time(end)],[30 30],'w--')
    pause(1)

    %% Define phases of interest

    % Check for discontinuities in LFP signals and delete the triggers
    % falling in that phase
    Trig{r} = check_for_discontinuities(Trig{r}, LFP, EMG); % I should implement here also something to 
    % delete triggers in case of discontinuity as LFP non existing after a while and removing the 
    % handle exception from get phase indexes

    [Indexes_LFP_referred{r}, TableBehavior{r}, TI_info{r}] = get_phase_indexes(Trig{r}, LFP, EMG, TableBehavior{r});


    %% Artifact cleaning

%     LFP_cut = LFP;
%     LFP_cut.data = LFP_cut.data(1 : 70300, :);
%     LFP_cut.time = 1/LFP_cut.Fs : 1/LFP_cut.Fs : size(LFP_cut.data, 1)/LFP_cut.Fs;
    [LFP_filtered, TI_info{r}] = clean_artifacts(LFP, TI_info{r}, tag);

    LFP_run{r} = LFP_filtered;
    if ~isempty(fields(TI_info{r}))
        TableBehavior{r}.TI_sequence = repelem({TI_info{r}.TIsequence_alignedToTrigger}, size(TableBehavior{r}, 1))';
    end

    % Clear variables before running next loop
    %clear behav behav_data_folder behav_filename data_folder ...
    %    EMG fileList fileNames LFP tag Trig trig_name trigger_filename ...
    %    TriggerInfo idx_behavfilename idxTrialsWoBaseline

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END DATA LOADING AND PRE-PROCESSING
%% TEST
for r = 1:length(run)
    x = Indexes_LFP_referred{2}{1, :};
    dx = diff(x)/250;
    disp(dx)
end

%%
for r = 1:length(run)
 
    %%%%%%%%%
    % Definition of a table containing offsets for the beginning and end 
    % indexes of a phase, needed in case we want to
    % modify phase boundaries.
    TableOffset = table('Size', [1 size(Indexes_LFP_referred{1}, 2)], ...
                     'VariableTypes', repmat({'cell'}, 1, size(Indexes_LFP_referred{1},2)), ...
                     'VariableNames', Indexes_LFP_referred{1}.Properties.VariableNames);

%     TableOffset.Intertrial = [+1 0]; % [+-x +-y] to remove/add seconds at the beginning or end of the phase 
    % TableOffset.PrepDM = {-0.8 [] 'From2'}; % baseline!!!!!!!!
    % TableOffset.DM_PreYN = {[] +0.5 'From1'};
%     TableOffset.DM_PreYN = {[] +0.7 'From1'}; % i2 will be i1+750ms
%     TableOffset.DM_PreYN = {-0.4 [] 'From2'}; 
    % TableOffset.DM_PostYN = {[] +1.1 'From1'}; % i2 will be i1+500ms
    % TableOffset.DM_PostYN = [0 +1]; 

    % TableOffset.Intertrial = {-0.8 [] 'From2'}; % i1 will be i2-2s
    % TableOffset.PrepEP = {-1 [] 'From2'}; % i1 will be i2-1s
    % TableOffset.EP = {[] +1 'From1'}; % i2 will be i1+8s
    % TableOffset.Feedb = {[] +1 'From1'}; % i2 will be i1+1s

    Modified_Indexes_LFP_referred{r} = modify_phase_indexes(Indexes_LFP_referred{r}, LFP_run{r}, TableOffset);
%     TableOffset = table('Size', [1 size(Indexes_LFP_referred{1}, 2)], ...
%                  'VariableTypes', repmat({'cell'}, 1, size(Indexes_LFP_referred{1},2)), ...
%                  'VariableNames', Indexes_LFP_referred{1}.Properties.VariableNames);
% 
%     TableOffset.DM_PostYN = [-0.2 0]; % i2 will be i1+500ms
% 
%     Modified_Indexes_LFP_referred{r} = modify_phase_indexes(Modified_Indexes_LFP_referred{r}, LFP_run{r}, TableOffset);



    %% TFR - Continuous Wavelet Transform

%     % Get the scalogram (magnitude!! absolute value of the CWT coefficients)
    % full_scalogram_CWT{r} = computeCWT(LFP_run{r}.data, LFP_run{r}, [3 100]);
% 
%     % Cut the scalogram in phases
    % TableScalogram_CWT{r} = spectrum_segmentation(full_scalogram_CWT{r}, Modified_Indexes_LFP_referred{r});
% 
%     % Normalise the scalogram to the baseline
    % [TableScalogram_CWT_norm{r}, idxTrialsWoBaseline] = normalize_power(TableScalogram_CWT{r}, 'TrialByTrial', 'PrepDM'); % baseline is usually 'PrepDM', but the FamEP trials don't have it and I use 'Intertrial'
%     % This is what we usually plot for visualization!!!!
%     
%     % Square the scalogram --> power!
%     full_squared_scalogram_CWT = full_scalogram_CWT;
%     full_squared_scalogram_CWT{r}.data = full_squared_scalogram_CWT{r}.data .^2;
% 
%     % Cut the squared scalogram in phases
%     TableSquaredScalogram_CWT{r} = spectrum_segmentation(full_squared_scalogram_CWT{r}, Modified_Indexes_LFP_referred{r});
% 
%     % Normalise the squared scalogram to the baseline
%     [TableSquaredScalogram_CWT_norm{r}, ~] = normalize_power(TableSquaredScalogram_CWT{r}, 'TrialByTrial', 'PrepDM'); % usually 'PrepDM', but the FamEP trials don't have it and I use 'Intertrial'
%     % This is what we use to compute power in different frequency bands 
% 
%     %%%%%%%
%     % Delete trials without baseline
%     TableScalogram_CWT{r}(idxTrialsWoBaseline, :) = [];
%     TableScalogram_CWT_norm{r}(idxTrialsWoBaseline, :) = [];
%     TableSquaredScalogram_CWT{r}(idxTrialsWoBaseline, :) = [];
%     TableSquaredScalogram_CWT_norm{r}(idxTrialsWoBaseline, :) = [];
%     TableBehavior{r}(idxTrialsWoBaseline, :) = [];

      
    %% LFP segmentation
    
    TableLFP{r} = LFP_recording_segmentation(LFP_run{r}.data, Modified_Indexes_LFP_referred{r});


    %% Power computation through FIR+Hilbert and segmentation

    FrequencyLimits = [3 6; 8 12; 12 30; 30 100]; % [3 6; 6 8; 8 12; 13 30; 30 100]; %; 7 12; 12 30; 30 80];
    FrequencyLimits(:,1) = FrequencyLimits(:,1) - 0.25;
    FrequencyLimits(:,2) = FrequencyLimits(:,2) + 0.25;
    FrequencyLabels = {'Theta', 'Alpha', 'Beta', 'Gamma'}; % 'HighTheta', 'Alpha', 'Beta', 'Gamma'}; %, 
    
    Flag_plot_filter = 0;
    StructPowerHilbert = compute_hilbert_power(LFP_run{r}, FrequencyLimits, FrequencyLabels, Flag_plot_filter);
    disp(length(LFP_run))

    for freq_idx = 1:size(FrequencyLimits,1)
        struct_fieldnames = fieldnames(StructPowerHilbert);
        tablename = strcat('TablePowerHilbert', struct_fieldnames{freq_idx});
        StructPowerHilbertSegmented = LFP_recording_segmentation(StructPowerHilbert.(struct_fieldnames{freq_idx}), Modified_Indexes_LFP_referred{r});
        
        % Normalisation
        % [StructPowerHilbertSegmented_norm, idxTrialsWoBaseline] = normalize_power(StructPowerHilbertSegmented, 'TrialByTrial', 'B1');
        StructPowerHilbertSegmented_norm = StructPowerHilbertSegmented;
        
        eval([tablename '{r} = StructPowerHilbertSegmented_norm;']);
    end

    %% Clear variables before running next loop
    clear behav behav_data_folder behav_filename data_folder ...
        EMG fileList fileNames LFP tag trig_name trigger_filename ...
        TriggerInfo idx_behavfilename idxTrialsWoBaseline StructPowerHilbert
end % end of the for loop on runs

%% Creation of a single table including all runs
% TablePSD = vertcat(TablePSD{:});
% TablePSD_norm = vertcat(TablePSD_norm{:});
All_TableBehavior = vertcat(TableBehavior{:});
% All_TableScalogram_CWT = vertcat(TableScalogram_CWT{:});
% All_TableScalogram_CWT_norm = vertcat(TableScalogram_CWT_norm{:});
% All_TableSquaredScalogram_CWT_norm = vertcat(TableSquaredScalogram_CWT_norm{:});
All_Modified_Indexes_LFP_referred = vertcat(Modified_Indexes_LFP_referred{:});
All_TablePowerHilbertAlpha = vertcat(TablePowerHilbertAlpha{:});
All_TablePowerHilbertBeta = vertcat(TablePowerHilbertBeta{:});
All_TablePowerHilbertGamma = vertcat(TablePowerHilbertGamma{:});
All_TablePowerHilbertTheta = vertcat(TablePowerHilbertTheta{:});

All_TablePowerHilbertTheta_behav = horzcat(All_TableBehavior, All_TablePowerHilbertTheta);
%% Delete trials (e.g. baseline corrupted)

% Deleting trials having DT<0.5s
% All_TablePowerHilbertTheta_behav(All_TablePowerHilbertTheta_behav.DecisionTime < 0.5, :) = [];
% 
% % Deleting trials in which the decision was anticipated / not made in time
% All_TablePowerHilbertTheta_behav(All_TablePowerHilbertTheta_behav.Acceptance == -1, :) = [];
% All_TablePowerHilbertTheta_behav(All_TablePowerHilbertTheta_behav.AnticipationDM == 1, :) = [];

%% 

TablePower = All_TablePowerHilbertTheta_behav;

TablePower.B0_Lhem = arrayfun(@(i) TablePower.B0{i}(1,1), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.BO_Rhem = arrayfun(@(i) TablePower.B0{i}(1,2), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.Stim1_Lhem = arrayfun(@(i) TablePower.Stim1{i}(1,1), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.Stim1_Rhem = arrayfun(@(i) TablePower.Stim1{i}(1,2), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.B1_Lhem = arrayfun(@(i) TablePower.B1{i}(1,1), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.B1_Rhem = arrayfun(@(i) TablePower.B1{i}(1,2), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.Stim2_Lhem = arrayfun(@(i) TablePower.Stim2{i}(1,1), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.Stim2_Rhem = arrayfun(@(i) TablePower.Stim2{i}(1,2), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.B2_Lhem = arrayfun(@(i) TablePower.B2{i}(1,1), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.B2_Rhem = arrayfun(@(i) TablePower.B2{i}(1,2), ...
        (1:height(TablePower))', 'UniformOutput', false);

%% Instantaneous Power

% Example data (replace with your X)
freq = 'Theta'; % Theta Alpha Beta Gamma 
PowerFreqData= eval(['All_TablePowerHilbert' freq]);


% Columns to plot (1 or 2)
columns_to_plot = [1 2];
side = ["Left", "Right"];

% Loop over the columns to create 2 plots
for c = 1:length(columns_to_plot)%2
    figure;
    hold on
    for row = 1:length(run)
        % Concatenate all 5 arrays in this row
        concat_data = [];
        for col = 1:5
            concat_data = [concat_data; PowerFreqData{row,col}{1}];  % vertical concatenation
        end
        
        % Plot the selected column
        Time = linspace(0, 3.5, length(concat_data(:, columns_to_plot(c))));
        plot(Time, concat_data(:, columns_to_plot(c)), 'LineWidth', 2);

    end
    hold off
    xlabel("Time (s)")
    ylabel("Power")
    title(['Instantaneous Power - ' char(freq) ' Band - ' char(side(c))]);
    xline([0.5, 1.5, 2.0, 3.0], 'w--', 'LineWidth', 3)    
    legend('iTBS','HF','cTBS','Sham', '', '', '', '')

end

%% Averaged Power

freq = 'Theta'; % Beta Gamma Theta
PowerFreqData = eval(['All_TablePowerHilbert' freq]);
side = 1; % 1 = Left, 2 = Right
groups = {[2 4], [1 3 5]};   % ON = 2+4, OFF = 1+3+5
group_titles = {'Average of ON phases', 'Average of OFF phases'};
sides = {'Left', 'Right'};

for g = 1:length(groups)
    figure; hold on
    
    for row = 1:length(run)
        % Collect signals
        sigs = cellfun(@(col) PowerFreqData{row,col}{1}(:,side), ...
                       num2cell(groups{g}), 'UniformOutput', false);

        % Find minimum length and truncate
        min_len = min(cellfun(@length, sigs));
        sigs = cellfun(@(x) x(1:min_len), sigs, 'UniformOutput', false);

        % Time vector: ON = 1s, OFF = 0.5s
        tmax = (g == 1) * 1.0 + (g == 2) * 0.5;
        Time = linspace(0, tmax, min_len);

        % --- Compute group average ---
        if g == 2  % OFF phases with conditional averaging
            halfPoint = floor(min_len/2);

            % First half: average only cols 3+5 → sigs{2}, sigs{3}
            avg_first = mean([sigs{2}(1:halfPoint), sigs{3}(1:halfPoint)], 2);

            % Second half: average cols 1+3+5 → sigs{1}, sigs{2}, sigs{3}
            avg_second = mean([sigs{1}(halfPoint+1:end), ...
                               sigs{2}(halfPoint+1:end), ...
                               sigs{3}(halfPoint+1:end)], 2);

            avg_data = [avg_first; avg_second];
        else
            % ON phases: average directly
            avg_data = mean(cat(2, sigs{:}), 2);
        end

        % --- Plot ---
        plot(Time, avg_data, 'LineWidth', 2);
    end
    
    hold off
    xlabel("Time (s)")
    ylabel("Averaged Power")
    title(['Instantaneous Power - ' freq ' Band - ' group_titles{g} ' - ' sides{side}]);
    legend({'iTBS','HF','cTBS','Sham'}, 'Location','best')
end



%% 
fs = 250;  % sampling rate (Hz)
LFP = LFP_run{1}.data;  % Nx2: [left, right]
[nSamples, nChan] = size(LFP);

[b, a] = butter(2, [1 100]/(fs/2));   % 2nd order
LFP_filt = filtfilt(b, a, double(LFP));

epochLen = 2 * fs; % 2s window
nEpochs = floor(nSamples / epochLen);
LFP_epochs = reshape(LFP_filt(1:nEpochs*epochLen, :), epochLen, nEpochs, nChan);

freqRes = 0.25;               % Hz
nfft = fs / freqRes;
freqs = (0:nfft/2) * fs/nfft; % frequency vector up to Nyquist
tapsmofrq = 2;                % ±2 Hz smoothing
nw = tapsmofrq / 0.5;         % time–bandwidth product for 2 Hz smoothing
[tapers, ~] = dpss(epochLen, nw, 'calc');

P = zeros(length(freqs), nChan);  % mean PSD across epochs
for ch = 1:nChan
    psd_accum = zeros(length(freqs), nEpochs);
    for e = 1:nEpochs
        x = LFP_epochs(:, e, ch);
        x = detrend(x) .* hann(epochLen);
        X = fft(x, nfft);
        psd_accum(:, e) = abs(X(1:nfft/2+1)).^2 / (fs*epochLen);
    end
    P(:, ch) = mean(psd_accum, 2);
end

osc_spec = zeros(size(P));
for ch = 1:nChan
    logf = log10(freqs(:));
    logp = log10(P(:, ch));
    fmask = freqs >= 1 & freqs <= 40;     % fit range
    b = robustfit(logf(fmask), logp(fmask));
    fit_logp = b(1) + b(2)*logf;           % 1/f fit
    aperiodic = 10.^fit_logp;
    osc_spec(:, ch) = P(:, ch) - aperiodic;
end

thetaRange = [3 8];
theta_power = zeros(1, nChan);

for ch = 1:nChan
    fmask = freqs >= thetaRange(1) & freqs <= thetaRange(2);
    [~, idxMax] = max(osc_spec(fmask, ch));
    theta_freqs = freqs(fmask);
    theta_peak = theta_freqs(idxMax);

    win = 1; % ±1 Hz
    pwMask = freqs >= theta_peak - win & freqs <= theta_peak + win;
    theta_power(ch) = mean(osc_spec(pwMask, ch));
end


winLen = 60 * fs;
step = 10 * fs;
startIdx = 1:step:(nSamples - winLen);
theta_time = zeros(length(startIdx), nChan);

for w = 1:length(startIdx)
    idx = startIdx(w):(startIdx(w)+winLen-1);
    seg = LFP_filt(idx, :);
    % --- reuse your PSD + aperiodic-removal + beta-power code here
    % (wrap the previous 3–5 steps into a function for cleanliness)
    % result -> beta_time(w, :)
end
time_axis = (startIdx + winLen/2) / fs;  % seconds



%% === Plot 1: Raw and 1/f-corrected power spectra ===

figure('Name','Power Spectra','Color','k');
chNames = {'Left', 'Right'};

for ch = 1:size(P,2)
    subplot(1,2,ch)
    plot(freqs, 10*log10(P(:,ch)), 'Color', [0.4 0.4 0.4], 'LineWidth', 1.5); hold on
    plot(freqs, 10*log10(osc_spec(:,ch)), 'r', 'LineWidth', 1.8);
    xlim([0 100]); xlabel('Frequency (Hz)');
    ylabel('Power (dB)');
    title(chNames{ch});
    legend('Raw PSD','Oscillatory (1/f removed)');
    grid on
end

sgtitle('LFP Power Spectrum — Raw vs. 1/f-corrected');

%% Plot 2: Zoom into Theta band (3-8 Hz)

betaRange = [3 8];

figure('Name','Theta Band Detail','Color','k');
for ch = 1:size(P,2)
    subplot(1,2,ch)
    fmask = freqs >= thetaRange(1) & freqs <= thetaRange(2);
    plot(freqs(fmask), 10*log10(osc_spec(fmask,ch)), 'w', 'LineWidth', 1.8);
    hold on; grid on
    [~, idxMax] = max(osc_spec(fmask,ch));
    thetaPeak = freqs(fmask); 
    thetaPeak = thetaPeak(idxMax);
    xline(thetaPeak, '--r', sprintf('%.1f Hz', thetaPeak), 'LineWidth', 1.2);
    xlabel('Frequency (Hz)');
    ylabel('Power (dB)');
    title([chNames{ch} ' — Theta Band']);
end
sgtitle('Theta-band Oscillatory Power');

%% Plot 3: Bar chart of Theta power (per channel)

figure('Name','Theta Power','Color','k');
bar(theta_power, 'FaceColor', [0.3 0.5 0.9]);
set(gca, 'XTickLabel', chNames, 'FontSize', 12);
ylabel('Mean Oscillatory Theta Power');
title('Mean theta-power (±1 Hz around peak)');
grid on

%% Plot 4: Time evolution of Beta power

if exist('theta_time','var')
    figure('Name','Time Evolution of Beta Power','Color','w');
    plot(time_axis, theta_time(:,1), 'r', 'LineWidth', 1.5); hold on
    plot(time_axis, theta_time(:,2), 'b', 'LineWidth', 1.5);
    xlabel('Time (s)');
    ylabel('theta-Power');
    title('Time Evolution of Oscillatory β-Power');
    legend(chNames, 'Location','best');
    grid on
end


%% Test

%% Parameters
fs = 250;                 % Sampling rate (Hz)
LFP = LFP_run{1}.data;    % Nx2: [Left, Right]
[nSamples, nChan] = size(LFP);

%% === 1. Bandpass filter 1–100 Hz (2nd order Butterworth, zero-phase) ===
[b, a] = butter(2, [1 100]/(fs/2));
LFP_filt = filtfilt(b, a, double(LFP));

%% === 2. Epoch-based PSD estimation ===
epochLen = 2 * fs;                      % 2 s window
nEpochs  = floor(nSamples / epochLen);
LFP_epochs = reshape(LFP_filt(1:nEpochs*epochLen, :), epochLen, nEpochs, nChan);

freqRes = 0.25;                         % Hz resolution
nfft    = fs / freqRes;
freqs   = (0:nfft/2) * fs/nfft;

P = zeros(length(freqs), nChan);        % Average PSD
for ch = 1:nChan
    psd_accum = zeros(length(freqs), nEpochs);
    for e = 1:nEpochs
        x = detrend(LFP_epochs(:, e, ch)) .* hann(epochLen);
        X = fft(x, nfft);
        psd_accum(:, e) = abs(X(1:nfft/2+1)).^2 / (fs*epochLen);
    end
    P(:, ch) = mean(psd_accum, 2);
end

%% === 3. Remove aperiodic component (1/f fit) ===
osc_spec = zeros(size(P));
for ch = 1:nChan
    logf = log10(freqs(:));
    logp = log10(P(:, ch));
    fmask = freqs >= 1 & freqs <= 40;   % Fit range
    bfit = robustfit(logf(fmask), logp(fmask));
    fit_logp = bfit(1) + bfit(2)*logf;
    aperiodic = 10.^fit_logp;
    osc_spec(:, ch) = P(:, ch) - aperiodic;
end

%% === 4. Theta band power (static) ===
thetaRange = [3 8];
theta_power = zeros(1, nChan);

for ch = 1:nChan
    fmask = freqs >= thetaRange(1) & freqs <= thetaRange(2);
    [~, idxMax] = max(osc_spec(fmask, ch));
    theta_freqs = freqs(fmask);
    theta_peak  = theta_freqs(idxMax);

    pwMask = freqs >= theta_peak - 1 & freqs <= theta_peak + 1;
    theta_power(ch) = mean(osc_spec(pwMask, ch));
end

%% === 5. Sliding window theta power (time evolution) ===
function thetaPow = compute_theta_power(seg, fs, nfft, freqs, thetaRange)
    x = detrend(seg) .* hann(length(seg));
    X = fft(x, nfft);
    P = abs(X(1:nfft/2+1)).^2 / (fs*length(seg));

    % Remove aperiodic
    logf = log10(freqs(:));
    logp = log10(P(:));
    fmask = freqs >= 1 & freqs <= 40;
    bfit = robustfit(logf(fmask), logp(fmask));
    fit_logp = bfit(1) + bfit(2)*logf;
    osc_spec = P(:) - 10.^fit_logp;

    % Theta peak
    fmask = freqs >= thetaRange(1) & freqs <= thetaRange(2);
    [~, idxMax] = max(osc_spec(fmask));
    theta_freqs = freqs(fmask);
    theta_peak  = theta_freqs(idxMax);

    pwMask = freqs >= theta_peak - 1 & freqs <= theta_peak + 1;
    thetaPow = mean(osc_spec(pwMask));
end

winLen   = 60 * fs;     % 60 s window
step     = 10 * fs;     % 10 s step
startIdx = 1:step:(nSamples - winLen);
theta_time = zeros(length(startIdx), nChan);

for w = 1:length(startIdx)
    idx = startIdx(w):(startIdx(w)+winLen-1);
    seg = LFP_filt(idx, :);
    for ch = 1:nChan
        theta_time(w,ch) = compute_theta_power(seg(:,ch), fs, nfft, freqs, thetaRange);
    end
end
time_axis = (startIdx + winLen/2) / fs;

%% === 6. Plots ===
chNames = {'Left', 'Right'};

% Plot 1: Raw and 1/f-corrected PSD
figure('Name','Power Spectra','Color','w');
for ch = 1:nChan
    subplot(1,2,ch)
    plot(freqs, 10*log10(P(:,ch)), 'k', 'LineWidth', 1.2); hold on
    plot(freqs, 10*log10(osc_spec(:,ch)), 'r', 'LineWidth', 1.5);
    xlim([0 40]); xlabel('Frequency (Hz)'); ylabel('Power (dB)');
    title(chNames{ch}); legend('Raw PSD','Oscillatory');
    grid on
end
sgtitle('LFP Power Spectrum (Raw vs. 1/f-corrected)');

% Plot 2: Theta band detail
figure('Name','Theta Band Detail','Color','w');
for ch = 1:nChan
    subplot(1,2,ch)
    fmask = freqs >= thetaRange(1) & freqs <= thetaRange(2);
    plot(freqs(fmask), 10*log10(osc_spec(fmask,ch)), 'b', 'LineWidth', 1.5);
    hold on; grid on
    [~, idxMax] = max(osc_spec(fmask,ch));
    thetaPeak = freqs(fmask); thetaPeak = thetaPeak(idxMax);
    xline(thetaPeak, '--r', sprintf('%.1f Hz', thetaPeak), 'LineWidth', 1.2);
    xlabel('Frequency (Hz)'); ylabel('Power (dB)');
    title([chNames{ch} ' — Theta Band']);
end
sgtitle('Theta-band Oscillatory Power');

% Plot 3: Bar chart of mean theta power
figure('Name','Theta Power','Color','w');
bar(theta_power, 'FaceColor', [0.3 0.5 0.9]);
set(gca, 'XTickLabel', chNames, 'FontSize', 12);
ylabel('Mean Oscillatory Theta Power'); title('Mean Theta Power (±1 Hz around peak)'); grid on

% Plot 4: Time evolution
figure('Name','Time Evolution','Color','w');
plot(time_axis, theta_time(:,1), 'r', 'LineWidth', 1.5); hold on
plot(time_axis, theta_time(:,2), 'b', 'LineWidth', 1.5);
xlabel('Time (s)'); ylabel('Theta Power');
title('Time Evolution of Oscillatory Theta Power');
legend(chNames, 'Location','best'); grid on



%% Metrics computation: Power@DMade 

TablePower = All_TablePowerHilbertTheta_behav;

TablePower.OfferPres_Lhem = arrayfun(@(i) TablePower.DM_PreYN{i}(1,1), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.OfferPres_Rhem = arrayfun(@(i) TablePower.DM_PreYN{i}(1,2), ...
        (1:height(TablePower))', 'UniformOutput', false);


TablePower.DMade_Lhem = arrayfun(@(i) TablePower.DM_PreYN{i}(end,1), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.DMade_Rhem = arrayfun(@(i) TablePower.DM_PreYN{i}(end,2), ...
        (1:height(TablePower))', 'UniformOutput', false);


TablePower.ContinuousSignal_OPto500ms_Lhem = arrayfun(@(i) TablePower.DM_PreYN{i}(...
        1 : 0.5*250, 1), ...
        (1:height(TablePower))', 'UniformOutput', false);

TablePower.ContinuousSignal_OPto500ms_Rhem = arrayfun(@(i) TablePower.DM_PreYN{i}(...
        1 : 0.5*250, 2), ...
        (1:height(TablePower))', 'UniformOutput', false);


%% Export table

% Remove block 1 and 5
R_Table = TablePower;

R_Table.CURSOR = [];
R_Table.TI_trigger = [];
R_Table.TI_sequence = [];
R_Table.Intertrial = [];
R_Table.ShowEffort = [];
R_Table.PrepDM = [];
R_Table.DM_PreYN = [];
R_Table.DM_PostYN = [];
R_Table.Hold = [];
R_Table.PrepEP = [];
R_Table.EP = [];
R_Table.WaitFeedb = [];
R_Table.Feedb = [];
R_Table.ReactionTime = [];
R_Table.EffortProd = [];
R_Table.AnticipationEP = [];
R_Table.Success = [];


writetable(R_Table, 'DBS_TI_Subj1_TableLowTheta.xlsx'); %_RespLocked500ms



%% Plotting DM phase per STIMULATION
                
StimValues = {'AM-DBS-180Hz-TI_HF', 'AM-DBS-180Hz-TI_iTBS'};
StimColors = [180 180 180; 255, 0, 125]/255;

nSamplesDMphase = 250; % 1s

MatrixAllMeanSignalsDM_StimBlocks = nan(nSamplesDMphase, 2);
MatrixAllSESignalsDM_StimBlocks = nan(nSamplesDMphase, 2);

hem = 1; % 1 is left


figure

for IdxStim = 1:length(StimValues)

    PowerDMphase_SingleTrial = TablePower(strcmp(TablePower.Phase, StimValues{IdxStim}) ...
        & TablePower.AnticipationDM == 0 ...
        & TablePower.Acceptance ~= -1, :);

    if isempty(PowerDMphase_SingleTrial)
        continue
    end

    % Select DM phase (buffer of 800ms before and 1s after)
    PowerDMphase_SingleTrial.DMSegment = arrayfun(@(i) PowerDMphase_SingleTrial.DM_PreYN{i}(:, hem), ... %PowerDMphase_SingleTrial.DMade(i)
        (1:height(PowerDMphase_SingleTrial))', 'UniformOutput', false);
    % Interpolate the DM phases to have a duration of 4s
    PowerDMphase_SingleTrial.DMSegment = arrayfun(@(x) ...
        interp1(1:length(PowerDMphase_SingleTrial.DMSegment{x}), ...
            PowerDMphase_SingleTrial.DMSegment{x}, ...
            linspace(1, length(PowerDMphase_SingleTrial.DMSegment{x}), nSamplesDMphase)), ...
        (1:height(PowerDMphase_SingleTrial.DMSegment))', 'UniformOutput', false);          
    allSegmentsDM = cat(1, PowerDMphase_SingleTrial.DMSegment{:});

    % Select PrepDM phase
    % PowerDMphase_SingleTrial.PrepDMSegment = arrayfun(@(i) PowerDMphase_SingleTrial.InterpolatedSignalBaselineRef{i}(:, ...
    % PowerDMphase_SingleTrial.StartDM(i) - nSamplesPrepDMphase :PowerDMphase_SingleTrial.StartDM(i)-1), ...
    % (1:height(PowerDMphase_SingleTrial))', 'UniformOutput', false);
    % allSegmentsPrepDM = cat(1, PowerDMphase_SingleTrial.PrepDMSegment{:});


    % Select buffer after DMade
    % PowerDMphase_SingleTrial.BufferPost = arrayfun(@(i) PowerDMphase_SingleTrial.InterpolatedSignalBaselineRef{i}(:, ...
    % PowerDMphase_SingleTrial.DMade(i)+1:PowerDMphase_SingleTrial.DMade(i)+nSamplesBuffer), ...
    % (1:height(PowerDMphase_SingleTrial))', 'UniformOutput', false);
    % allSegmentsBufferPost = cat(1, PowerDMphase_SingleTrial.BufferPost{:});

    AllSegments = [allSegmentsDM];
    

    MeanSignal = mean(AllSegments);
    SESignal = std(AllSegments) / sqrt(size(AllSegments,1));

    TimeSegment = 1:length(MeanSignal);
    plot(TimeSegment, MeanSignal, 'color', StimColors(IdxStim, :), 'LineWidth', 2)
    hold on
    fill([TimeSegment, fliplr(TimeSegment)], ...
        [MeanSignal + SESignal, fliplr(MeanSignal - SESignal)], ...
        StimColors(IdxStim, :), 'EdgeColor', 'none', 'FaceAlpha', 0.4); % Red shade
    hold on


    % Store data
    MatrixAllMeanSignalsDM_StimBlocks(:, IdxStim) = MeanSignal;
    MatrixAllSESignalsDM_StimBlocks(:, IdxStim) = SESignal;

    
end

    

% axes limits
ylim([-10 10])
xlim([0 nSamplesDMphase])

% ticks
% xticks([nSamplesPrepDMphase, nSamplesPrepDMphase+nSamplesDMphase, nSamplesPrepDMphase+nSamplesDMphase+nSamplesBuffer])
% xticklabels({"0", "x", "x+0.5 s"})
xticks([0, nSamplesDMphase])
xticklabels({"StartDM", "DMade"})
ylabel("Power")



% vertical reference lines
% xline(nSamplesPrepDMphase, '-', 'StartDM', 'FontSize', 14)
% xline(nSamplesPrepDMphase+nSamplesDMphase, '-', 'Decision Made', 'FontSize', 14)
% xline(0.5*500, '-', 'End baseline', 'FontSize', 14)
% xline(nSamplesPrepDMphase, '-')
% xline(nSamplesPrepDMphase+nSamplesDMphase, '-')
% xline(0.5*500, '-')

% Shaded area for the baseline
% x1 = 0;
% x2 = 0.5*500;
% y1 = ylim;  % current y-axis limits
% 
% patch([x1 x2 x2 x1], [y1(1) y1(1) y1(2) y1(2)], ...
%       [0.8 0.8 0.8], 'FaceAlpha', 0.3, 'EdgeColor', 'none');


% remove top and left axes
ax = gca;
ax.Box = 'off';
ax.XColor = 'k'; % bottom x-axis color
ax.YColor = 'k'; % right y-axis color
ax.LineWidth = 2; % thickness of axes

% move y-axis to right
ax.YAxisLocation = 'left';
ax.XAxisLocation = 'bottom';

ax = gca;
ax.TickLength = [0 0];  % removes tick marks but keeps labels

ax.FontSize = 14;  % increase number labels on both axes


%% Plotting DM phase per EFFORT 

TablePower = All_TablePowerHilbertTheta_behav;

TablePowerEffort = TablePower;
TablePowerEffort(~strcmp(TablePowerEffort.Phase, 'AM-DBS-180Hz-TI_HF'), :) = [];

TablePowerEffort.Effort(ismember(TablePowerEffort.Effort, [0.45 0.6])) = 0;
TablePowerEffort.Effort(ismember(TablePowerEffort.Effort, [0.75 0.9])) = 1;

EffortValues = [0 1];
EffortColors = [0 114 178; 213, 94, 0]/255;

nSamplesDMphase = size(TablePower.DM_PreYN{1}, 1); % 1s
nSamplesPrepDM = 0; % 1s

MatrixAllMeanSignalsDM_StimBlocks = nan(nSamplesDMphase+nSamplesPrepDM, 2);
MatrixAllSESignalsDM_StimBlocks = nan(nSamplesDMphase+nSamplesPrepDM, 2);

hem = 2; % 1 is left, 2 is right

N_trials_included = [];


figure

for IdxEffort = 1:2

    PowerDMphase_SingleTrial = TablePowerEffort(TablePowerEffort.Effort == EffortValues(IdxEffort), :);

    if isempty(PowerDMphase_SingleTrial)
        continue
    end

    % Select DM phase (buffer of 800ms before and 1s after)
    PowerDMphase_SingleTrial.DMSegment = arrayfun(@(i) PowerDMphase_SingleTrial.DM_PreYN{i}(:, hem), ... %PowerDMphase_SingleTrial.DMade(i)
        (1:height(PowerDMphase_SingleTrial))', 'UniformOutput', false);
    % Interpolate the DM phases to have a duration of 4s
    % PowerDMphase_SingleTrial.DMSegment = arrayfun(@(x) ...
    %     interp1(1:length(PowerDMphase_SingleTrial.DMSegment{x}), ...
    %         PowerDMphase_SingleTrial.DMSegment{x}, ...
    %         linspace(1, length(PowerDMphase_SingleTrial.DMSegment{x}), nSamplesDMphase)), ...
    %     (1:height(PowerDMphase_SingleTrial.DMSegment))', 'UniformOutput', false);          
    allSegmentsDM = cat(2, PowerDMphase_SingleTrial.DMSegment{:})';

    % Select PrepDM phase
    % PowerDMphase_SingleTrial.PrepDMSegment = arrayfun(@(i) PowerDMphase_SingleTrial.PrepDM{i}(:, hem), ... %PowerDMphase_SingleTrial.DMade(i)
    %     (1:height(PowerDMphase_SingleTrial))', 'UniformOutput', false);
    % allSegmentsPrepDM = cat(2, PowerDMphase_SingleTrial.PrepDMSegment{:});


    % Select buffer after DMade
    % PowerDMphase_SingleTrial.BufferPost = arrayfun(@(i) PowerDMphase_SingleTrial.InterpolatedSignalBaselineRef{i}(:, ...
    % PowerDMphase_SingleTrial.DMade(i)+1:PowerDMphase_SingleTrial.DMade(i)+nSamplesBuffer), ...
    % (1:height(PowerDMphase_SingleTrial))', 'UniformOutput', false);
    % allSegmentsBufferPost = cat(1, PowerDMphase_SingleTrial.BufferPost{:});

    AllSegments = [allSegmentsDM];
    
    N_trials_included = [N_trials_included size(AllSegments, 1)];


    MeanSignal = mean(AllSegments);
    SESignal = std(AllSegments) / sqrt(size(AllSegments,1));

    TimeSegment = 1:length(MeanSignal);
    plot(TimeSegment, MeanSignal, 'color', EffortColors(IdxEffort, :), 'LineWidth', 2)
    hold on
    fill([TimeSegment, fliplr(TimeSegment)], ...
        [MeanSignal + SESignal, fliplr(MeanSignal - SESignal)], ...
        EffortColors(IdxEffort, :), 'EdgeColor', 'none', 'FaceAlpha', 0.4); % Red shade
    hold on


    % Store data
    MatrixAllMeanSignalsDM_StimBlocks(:, IdxEffort) = MeanSignal;
    MatrixAllSESignalsDM_StimBlocks(:, IdxEffort) = SESignal;


    
end

legend({sprintf('Low Effort - N=%d', N_trials_included(1)), 'Low Effort SE', sprintf('High Effort - N=%d', N_trials_included(2)), 'High Effort SE'})
title(sprintf('%s', TablePowerEffort.Phase{1}))

% axes limits
% ylim([-10 10])
xlim([0 nSamplesDMphase])

% ticks
% xticks([nSamplesPrepDMphase, nSamplesPrepDMphase+nSamplesDMphase, nSamplesPrepDMphase+nSamplesDMphase+nSamplesBuffer])
% xticklabels({"0", "x", "x+0.5 s"})
xticks([0, nSamplesDMphase])
xticklabels({"StartDM", "StartDM+500ms"})
ylabel("Power")



% vertical reference lines
% xline(nSamplesPrepDMphase, '-', 'StartDM', 'FontSize', 14)
% xline(nSamplesPrepDMphase+nSamplesDMphase, '-', 'Decision Made', 'FontSize', 14)
% xline(0.5*500, '-', 'End baseline', 'FontSize', 14)
% xline(nSamplesPrepDMphase, '-')
% xline(nSamplesPrepDMphase+nSamplesDMphase, '-')
% xline(0.5*500, '-')

% Shaded area for the baseline
% x1 = 0;
% x2 = 0.5*500;
% y1 = ylim;  % current y-axis limits
% 
% patch([x1 x2 x2 x1], [y1(1) y1(1) y1(2) y1(2)], ...
%       [0.8 0.8 0.8], 'FaceAlpha', 0.3, 'EdgeColor', 'none');


% remove top and left axes
ax = gca;
ax.Box = 'off';
ax.XColor = 'k'; % bottom x-axis color
ax.YColor = 'k'; % right y-axis color
ax.LineWidth = 2; % thickness of axes

% move y-axis to right
ax.YAxisLocation = 'left';
ax.XAxisLocation = 'bottom';

ax = gca;
ax.TickLength = [0 0];  % removes tick marks but keeps labels

ax.FontSize = 14;  % increase number labels on both axes


%% Creation of a subset based on behavior

% NameBehavCondition = {'Low Rew', 'High Rew'};
NameBehavCondition = {'Low Eff', 'High Eff'};
% NameBehavCondition = {'NO', 'YES'};
TableBehavCondition = table('Size', [1 size(All_TableBehavior, 2)], ...
                     'VariableTypes', repmat({'cell'}, 1, size(All_TableBehavior,2)), ...
                     'VariableNames', All_TableBehavior.Properties.VariableNames);

% TableBehavCondition.Effort = {[0.5 0.65; 0.8 0.95]}; % PD - Split low and high efforts
TableBehavCondition.Effort = {[0.45 0.6; 0.75 0.90]}; % PD TI - Split low and high efforts
TableBehavCondition.Phase = {'AM-DBS-180Hz-TI_iTBS'}; % PD TI - Split low and high efforts

% TableBehavCondition.Reward = {[1 5; 10 20]}; 

% TableBehavCondition.Effort = {[0.45 0.60; 0.75 0.90]}; % OCD - Split low and high efforts 
% TableBehavCondition.Reward = {[1 5; 10 20]}; % Split low and high rewards
% TableBehavCondition.Acceptance = {[0; 1]}; 
% TableBehavCondition.Acceptance = {1}; 
% TableBehavCondition.EffortProd = {1}; % if only one condition, it will be applied to the whole dataset!
% TableBehavCondition.Block = {'B1&B4'}; % 'B5&B6'


% [TablePSD_norm_subset, TableBehavSubset] = get_subset_based_on_behavior(TablePSD_norm, All_TableBehavior, TableBehavCondition);

[TableScalogram_CWT_norm_subset, TableBehavSubset] = get_subset_based_on_behavior(All_TableScalogram_CWT_norm, All_TableBehavior, TableBehavCondition);

% [TableFourier_norm_subset, TableBehavSubset] = get_subset_based_on_behavior(TableFourier_norm, All_TableBehavior, TableBehavCondition);



%% CTW - averaging and plotting scalograms 
params.frequencies = full_scalogram_CWT{1}.frequencies;

% Time warping
% N.B. if the segments of a phase have already all the same length, this 
% function leaves them unaltered!!!!
TableScalogram_CWT_norm_TW = time_warping_segments(TableScalogram_CWT_norm_subset);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOT DM PHASE
%PrepDM is the baseline, doesn't make sense to plot it
Labels_ColumnToAverage = {'DM_PreYN' 'DM_PostYN'}; 
% Labels_ColumnToAverage = {'DM_PreYN'}; 

[signal_to_plot, cut_idx, N] = average_and_combine_segments(TableScalogram_CWT_norm_TW, Labels_ColumnToAverage);
% Labels_Plot = {'DMade-0.4s' 'DMade' 'DM+1s'};
Labels_Plot = {'StartDM-0.4s' 'DMade' 'DMade+1s'};
% Labels_Plot = {'StartDM' 'StartDM+0.4s' };

params.frequencies = full_scalogram_CWT{1}.frequencies;
plot_scalogram(signal_to_plot, cut_idx, LFP_run, params, Labels_Plot, N)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOT DM+EP PHASE or only EP PHASE

plot_TableScalogram_CWT_norm = TableScalogram_CWT_norm_TW;
% plot_TableScalogram_CWT_norm(All_TableBehavior.AnticipationEP == 1 | All_TableBehavior.EffortProd ~= 1, :) = [];
% plot_All_TableBehavior = All_TableBehavior;
% plot_All_TableBehavior(plot_All_TableBehavior.AnticipationEP == 1 | plot_All_TableBehavior.EffortProd ~= 1, :) = [];

Labels_ColumnToAverage = {'DM_PreYN', 'DM_PostYN', 'Hold', 'PrepEP', 'EP', 'WaitFeedb', 'Feedb'}; 
% Labels_ColumnToAverage = {'ShowEffort', 'Hold', 'PrepEP', 'EP', 'Feedb'}; 
% Labels_ColumnToAverage = {'Hold', 'PrepEP', 'EP'}; 
[signal_to_plot, cut_idx, N] = average_and_combine_segments(plot_TableScalogram_CWT_norm, Labels_ColumnToAverage);
% Labels_Plot = {'Hold', 'PrepEP', 'Start EP'};
Labels_Plot = {'StartDM', 'DMade', 'Hold', 'PrepEP', 'Start EP', 'WF', 'F'};

params.frequencies = full_scalogram_CWT{1}.frequencies;
plot_scalogram(signal_to_plot, cut_idx, LFP_run, params, Labels_Plot, N)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOT Y/N or Leff/Heff OR Lrew/Hrew
plot_TableScalogram_CWT_norm_TW_1 = time_warping_segments(TableScalogram_CWT_norm_subset{1});
plot_TableScalogram_CWT_norm_TW_2 = time_warping_segments(TableScalogram_CWT_norm_subset{2});

% Ndiff = size(plot_TableScalogram_CWT_norm_TW_2, 1) - size(plot_TableScalogram_CWT_norm_TW_1, 1);
% DeleteIdx = randperm(size(plot_TableScalogram_CWT_norm_TW_2, 1), Ndiff);
% plot_TableScalogram_CWT_norm_TW_2(DeleteIdx, :) = [];

Labels_ColumnToAverage = {'DM_PreYN'}; 
% Labels_ColumnToAverage = {'DM_PreYN', 'DM_PostYN'}; 
% Labels_ColumnToAverage = {'Hold', 'PrepEP', 'EP'}; 
% Labels_Plot = {''};
% Labels_Plot = {'DMade-750ms' 'DMade' 'DMade+1s'};
Labels_Plot = {'StartDM' 'DMade'};
% Labels_Plot = {'StartDM-0.4s' 'DMade' 'DMade+1s'};
% Labels_Plot = {'Hold', 'PrepEP', 'Start EP'};

[signal_to_plot, cut_idx, N] = average_and_combine_segments(plot_TableScalogram_CWT_norm_TW_1, Labels_ColumnToAverage);
plot_scalogram(signal_to_plot, cut_idx, LFP_run, params, Labels_Plot, N)

[signal_to_plot, cut_idx, N] = average_and_combine_segments(plot_TableScalogram_CWT_norm_TW_2, Labels_ColumnToAverage);
plot_scalogram(signal_to_plot, cut_idx, LFP_run, params, Labels_Plot, N)




%% Power

[TableInstantaneousPower_Hilbert_norm_subset, TableBehavSubset] = get_subset_based_on_behavior(All_TableInstantaneousPower_Hilbert_norm, All_TableBehavior, TableBehavCondition);

% FrequencyLimits = [3 6]; %; 6 12; 13 30; 31 100];
% FrequencyLabels = {'Theta'}; %, 'Alpha', 'Beta', 'Gamma'};
FrequencyLimits = [3 7; 7 12; 12 30; 30 80];
FrequencyLabels = {'Theta', 'Alpha', 'Beta', 'Gamma'};
NamePhasesOfInterest = {'FullSignal'};

[TablePower_mean_SE_subset1, TablePower_band_single_trial_subset1] = compute_band_average_power(TableInstantaneousPower_Hilbert_norm_subset{1}, FrequencyLimits, FrequencyLabels);

[TablePower_mean_SE_subset2, TablePower_band_single_trial_subset2] = compute_band_average_power(TableInstantaneousPower_Hilbert_norm_subset{2}, FrequencyLimits, FrequencyLabels);

plot_band_average_power({TablePower_mean_SE_subset1, TablePower_mean_SE_subset2}, NameBehavCondition, NamePhasesOfInterest, {TablePower_band_single_trial_subset1, TablePower_band_single_trial_subset2})

% For behavioral subsets
[TableSpectrogram_average_subset1, TableSpectrogram__SE_subset1, N1] = compute_band_average_spectrogram(TableInstantaneousPower_Hilbert_norm_subset{1}, FrequencyLimits, FrequencyLabels);
[TableSpectrogram_average_subset2, TableSpectrogram__SE_subset2, N2] = compute_band_average_spectrogram(TableInstantaneousPower_Hilbert_norm_subset{2}, FrequencyLimits, FrequencyLabels);

plot_band_average_spectrogram({TableSpectrogram_average_subset1, TableSpectrogram_average_subset2}, {TableSpectrogram__SE_subset1, TableSpectrogram__SE_subset2}, NameBehavCondition, NamePhasesOfInterest, [N1 N2])

% For full dataset
[TableSpectrogram_average, TableSpectrogram__SE, N] = compute_band_average_spectrogram(All_TableInstantaneousPower_Hilbert_norm, FrequencyLimits, FrequencyLabels);
plot_band_average_spectrogram(TableSpectrogram_average, TableSpectrogram__SE, NameBehavCondition, NamePhasesOfInterest, N)



[TablePower_mean_SE, TablePower_band_single_trial] = compute_band_average_power(TableInstantaneousThetaPower_Hilbert_norm, FrequencyLimits, FrequencyLabels);

R_table_Theta_StimLocked = All_TableBehavior(:,1:9);
R_table_Theta_StimLocked.Theta_Rhem = TablePower_band_single_trial{"Theta", "DM_PreYN"}{:}(:,2);
R_table_Theta_StimLocked.Theta_Lhem = TablePower_band_single_trial{"Theta", "DM_PreYN"}{:}(:,1);
R_table_Theta_StimLocked.Gamma_Rhem = TablePower_band_single_trial{"Gamma", "DM_PreYN"}{:}(:,2);
R_table_Theta_StimLocked.Gamma_Lhem = TablePower_band_single_trial{"Gamma", "DM_PreYN"}{:}(:,1);


writetable(R_table_Theta_StimLocked, 'R_TI_DBS1_exported20250513.xlsx');

% Theta_Rhem = NaN(20,1)
% Theta_Lhem = NaN(20,1)
% Gamma_Lhem = NaN(20,1)
% Gamma_Rhem = NaN(20,1)
% NewPasteBehavior.Theta_Rhem = Theta_Rhem
% NewPasteBehavior.Theta_Lhem = Theta_Lhem
% NewPasteBehavior.Gamma_Rhem = Gamma_Rhem
% NewPasteBehavior.Gamma_Lhem = Gamma_Lhem
% Pre_R_table_Theta_StimLocked = R_table_Theta_StimLocked(1:44, :)
% Post_R_table_Theta_StimLocked = R_table_Theta_StimLocked(45:end, :)
% NEW = [Pre_R_table_Theta_StimLocked; NewPasteBehavior; Post_R_table_Theta_StimLocked]
% writetable(NEW, 'R_TI_DBS1_IncludingDisconnection_exported20250514.xlsx');



Labels_ColumnToAverage = 'DM_PreYN';
figure
[signal_to_plot1, cut_idx, N] = average_and_combine_segments(TableInstantaneousThetaPower_Hilbert_subset{1}, Labels_ColumnToAverage);
SE = std(signal_to_plot1(:,2))/sqrt(N);
errorbar(1, mean(signal_to_plot1(:,2)), SE, 'b')
% plot(signal_to_plot(:,2), 'b')
hold on
[signal_to_plot2, cut_idx, N] = average_and_combine_segments(TableInstantaneousThetaPower_Hilbert_subset{2}, Labels_ColumnToAverage);
SE = std(signal_to_plot2(:,2))/sqrt(N);
errorbar(1.2, mean(signal_to_plot2(:,2)), SE, 'r')
% plot(signal_to_plot(:,2), 'r')
legend('Low effort', 'High effort')
xlim([0.9 1.3])
ylim([5 15])
% xticklabels([0:20:120]/LFP_run{1}.Fs)


diff = signal_to_plot1(:,2)-signal_to_plot2(:,2); 
figure
plot(diff)
ylim([-4 4])


%% Subset of trials based on when the stimulation happens

% iTBS burst every 200 ms for 2s --> 500 samples per train!
% > 8s means at least one burst during the phase


Trial_w_concurrent_TI_PrepDM = zeros(size(TableBehavSubset,1),2);
Trial_w_concurrent_TI_PreYN = zeros(size(TableBehavSubset,1),2);
Trial_w_concurrent_TI_PostYN = zeros(size(TableBehavSubset,1),2);


for n = 1:size(TableBehavSubset, 1)
    N_samples_overlap = numel(intersect( find(TableBehavSubset.TI_sequence{n}), ...
        [All_Modified_Indexes_LFP_referred.PrepDM(n,1) : All_Modified_Indexes_LFP_referred.PrepDM(n,2)] ));
    if N_samples_overlap > 8
        Trial_w_concurrent_TI_PrepDM(n,1) = 1;
        Trial_w_concurrent_TI_PrepDM(n,2) = N_samples_overlap;
    else
        Trial_w_concurrent_TI_PrepDM(n,2) = N_samples_overlap;

    end
end
disp(sum(Trial_w_concurrent_TI_PrepDM))

for n = 1:size(TableBehavSubset, 1)
    N_samples_overlap = numel(intersect( find(TableBehavSubset.TI_sequence{n}), ...
        [All_Modified_Indexes_LFP_referred.DM_PreYN(n,1) : All_Modified_Indexes_LFP_referred.DM_PreYN(n,2)] ));
    if N_samples_overlap > 8
        Trial_w_concurrent_TI_PreYN(n,1) = 1;
        Trial_w_concurrent_TI_PreYN(n,2) = N_samples_overlap;
    else
        Trial_w_concurrent_TI_PreYN(n,2) = N_samples_overlap;

    end
end
disp(sum(Trial_w_concurrent_TI_PreYN))


for n = 1:size(TableBehavSubset, 1)
    N_samples_overlap = numel(intersect( find(TableBehavSubset.TI_sequence{n}), ...
        [All_Modified_Indexes_LFP_referred.DM_PostYN(n,1) : All_Modified_Indexes_LFP_referred.DM_PostYN(n,2)] ));
    if N_samples_overlap > 8
        Trial_w_concurrent_TI_PostYN(n,1) = 1;
        Trial_w_concurrent_TI_PostYN(n,2) = N_samples_overlap;
    else
        Trial_w_concurrent_TI_PostYN(n,2) = N_samples_overlap;

    end
end
disp(sum(Trial_w_concurrent_TI_PostYN))

Trial_w_concurrent_TI_PrepDM_and_PreYN = Trial_w_concurrent_TI_PrepDM(:,1) | Trial_w_concurrent_TI_PreYN(:,1);

% Delete trials
% TableScalogram_CWT_norm_subset(find(Trial_w_concurrent_TI_PreYN(:,1)), :) = [];
% TableBehavSubset(find(Trial_w_concurrent_TI_PreYN(:,1)), :) = [];
TableScalogram_CWT_norm_subset_original = TableScalogram_CWT_norm_subset;
TableScalogram_CWT_norm_subset(find(Trial_w_concurrent_TI_PreYN(:,1)), :) = []; %~

TableScalogram_CWT_norm_subset_concurrentBurst = TableScalogram_CWT_norm_subset;
TableScalogram_CWT_norm_subset_wo_concurrentBurst = TableScalogram_CWT_norm_subset;

% DeleteIdx = randperm(size(TableScalogram_CWT_norm_subset, 1), 50);
% TableScalogram_CWT_norm_subset(DeleteIdx, :) = [];
% TableBehavSubset(DeleteIdx, :) = [];
params.frequencies = full_scalogram_CWT{1}.frequencies;

plot_TableScalogram_CWT_norm_TW_1 = time_warping_segments(TableScalogram_CWT_norm_subset_concurrentBurst);
plot_TableScalogram_CWT_norm_TW_2 = time_warping_segments(TableScalogram_CWT_norm_subset_wo_concurrentBurst);

% Ndiff = size(plot_TableScalogram_CWT_norm_TW_2, 1) - size(plot_TableScalogram_CWT_norm_TW_1, 1);
% DeleteIdx = randperm(size(plot_TableScalogram_CWT_norm_TW_2, 1), Ndiff);
% plot_TableScalogram_CWT_norm_TW_2(DeleteIdx, :) = [];

Labels_ColumnToAverage = {'DM_PreYN', 'DM_PostYN'}; 
% Labels_ColumnToAverage = {'DM_PreYN', 'DM_PostYN'}; 
% Labels_ColumnToAverage = {'Hold', 'PrepEP', 'EP'}; 
% Labels_Plot = {''};
% Labels_Plot = {'DMade-750ms' 'DMade' 'DMade+1s'};
% Labels_Plot = {'StartDM' 'DMade'};
Labels_Plot = {'StartDM' 'DMade' 'DMade+1s'};
% Labels_Plot = {'Hold', 'PrepEP', 'Start EP'};

[signal_to_plot, cut_idx, N] = average_and_combine_segments(plot_TableScalogram_CWT_norm_TW_1, Labels_ColumnToAverage);
plot_scalogram(signal_to_plot, cut_idx, LFP_run, params, Labels_Plot, N)

[signal_to_plot, cut_idx, N] = average_and_combine_segments(plot_TableScalogram_CWT_norm_TW_2, Labels_ColumnToAverage);
plot_scalogram(signal_to_plot, cut_idx, LFP_run, params, Labels_Plot, N)











%%
TableScalogram_CWT_norm_subset_2 = TableScalogram_CWT_norm_subset_original;

TableScalogram_CWT_norm_subset_2(find(Trial_w_concurrent_TI_PrepDM_and_PreYN), :) = [];

DeleteIdx = randperm(size(TableScalogram_CWT_norm_subset_2, 1), 38);
TableScalogram_CWT_norm_subset_2(DeleteIdx, :) = [];


% I have now two TableScalogram_CWT_norm_subset_concurrentBurst and TableScalogram_CWT_norm_subset_wo_concurrentBurst


%% MULTIPLE COMPARISON
close all 

% DatasetA = TableScalogram_CWT_norm_subset_concurrentBurst.DM_PreYN;
% DatasetB = TableScalogram_CWT_norm_subset_wo_concurrentBurst.DM_PreYN;
DatasetA = TableScalogram_CWT_norm_subset{1}.DM_PreYN;
DatasetB = TableScalogram_CWT_norm_subset{2}.DM_PreYN;
% DatasetA = cellfun(@(x) x(70:152, :, :), TableScalogram_CWT_norm_subset{1}, 'UniformOutput', false);
% DatasetB = cellfun(@(x) x(70:152, :, :), TableScalogram_CWT_norm_subset{2}, 'UniformOutput', false);

% DatasetB = DatasetA;
All_Datasets = vertcat(DatasetA, DatasetB);

% Example setup
nTrialsA = size(DatasetA,1);  % Number of trials in Condition A
nTrialsB = size(DatasetB,1);  % Number of trials in Condition B
nPermutations = 1000;  % Number of permutations for the test
freqIdx = size(DatasetA{1}, 1);  % Frequency bins
timeIdx = size(DatasetA{1}, 2);  % Time points
nHemispheres = size(DatasetA{1}, 3);  % Two hemispheres: left and right

% Initialize observed statistics and permutation stats containers
obsStats = zeros(freqIdx, timeIdx, nHemispheres);  % Observed test statistics (difference of means)
permStats = zeros(nPermutations, freqIdx, timeIdx, nHemispheres);  % Permutation distribution
ThresholdMap = zeros(freqIdx, timeIdx, nHemispheres);

% Loop over each frequency bin, time point, and hemisphere
for h = 1:nHemispheres
    for f = 1:freqIdx
        for t = 1:timeIdx
            % Extract all data for ONE PIXEL from each trial
            allData = [];
            for i = 1:nTrialsA + nTrialsB % loop over trials 
                allData = [allData; All_Datasets{i}(f, t, h)];  % Collect data from both conditions
            end

            % Step 1: Calculate the observed test statistic (difference of means)
            dataA = allData(1:nTrialsA);  % Data from Condition A (first 32 trials)
            dataB = allData(nTrialsA+1:end);  % Data from Condition B (next 96 trials)
            obsStats(f, t, h) = mean(dataB) - mean(dataA); % difference of means for a specific pixel in the two conditions

            % Step 2: Generate permutation statistics
            for perm = 1:nPermutations
                % Shuffle the combined data and randomly assign trials to both conditions
                shuffledData = allData(randperm(length(allData)));  % Shuffle the data randomly

                % Split the shuffled data into two new conditions, with the original sizes
                newDataA = shuffledData(1:nTrialsA);  % New Condition A after shuffle
                newDataB = shuffledData(nTrialsA+1:end);  % New Condition B after shuffle

                % Calculate the test statistic for the permuted data
                permStats(perm, f, t, h) = mean(newDataB) - mean(newDataA);
            end

            % Get the thresholding map as the 95% percentile of the null hp
            % distribution for each pixel
            ThresholdMap(f, t, h) = prctile(permStats(:, f, t, h), 95);

        end
    end
end

% Now I have the null hp distribution for each pixel and the thresholding
% map!



% Loop over each null-hypothesis map to threshold it, then identify
% clusters and select the ones with most extreme values
Distribution_biggest_suprath_clusters = zeros(nPermutations, nHemispheres);

for h = 1:nHemispheres
    for perm = 1:nPermutations

        NullHpMap = squeeze(permStats(perm, :, :, h));
        % figure
        % imagesc(NullHpMap)
        % colorbar

        % TODO: try taking the absolute value of NullHpMap here
        NullHpMap_thresholded = NullHpMap;
        NullHpMap_thresholded(NullHpMap_thresholded < ThresholdMap(:, :, h)) = 0;
        % figure
        % imagesc(NullHpMap_thresholded)
        % colorbar

        % Identify clusters

        CC = bwconncomp(NullHpMap_thresholded);
        nClusters = CC.NumObjects;

        cluster_masses = zeros(nClusters,1);
        for i = 1:nClusters
            cluster_masses(i) = sum(NullHpMap_thresholded(CC.PixelIdxList{i}));
        end

        % cluster_sizes = cellfun(@numel, CC.PixelIdxList);
        % Find the biggest cluster (by mass or by size)
        [max_size, idx_max] = max(cluster_masses);
        Distribution_biggest_suprath_clusters(perm, h) = max_size;
        biggest_cluster_indices = CC.PixelIdxList{idx_max};

        % selected_cluster_map = NullHpMap_thresholded;
        % mask = false(size(NullHpMap_thresholded));
        % mask(CC.PixelIdxList{idx_max}) = true;
        % 
        % % Set everything outside the cluster to zero
        % selected_cluster_map(~mask) = 0;
        % figure
        % imagesc(selected_cluster_map)
        % colorbar
        
    end
end

% Threshold the map of observed statistical values with the same
% pre-cluster method to find clusters
ObsStats_thresholded = obsStats;
ObsStats_thresholded(abs(ObsStats_thresholded) < ThresholdMap) = 0;

% Find significant clusters
SignificantClusters = struct();

for h = 1:nHemispheres 

    % Identify clusters
    CC = bwconncomp(ObsStats_thresholded(:,:,h));
    nClusters = CC.NumObjects;
    
    cluster_masses = zeros(nClusters,1);
    for i = 1:nClusters
        cluster_masses(i) = sum(ObsStats_thresholded(CC.PixelIdxList{i}));
    end
    
    % % Find the biggest cluster (by mass or by size)
    % [max_size, idx_max] = max(cluster_masses);
    % 
    % selected_cluster_map = ObsStats_thresholded(:,:,h);
    % mask = false(size(ObsStats_thresholded(:,:,h)));
    % mask(CC.PixelIdxList{idx_max}) = true;

    % Set everything outside the cluster to zero
    % selected_cluster_map(~mask) = 0;
    % figure
    % imagesc(selected_cluster_map)
    % colorbar
    
    % Find 95th percentile of the distribution of biggest suprathreshold
    % clusters 
    ClusterThreshold = prctile(Distribution_biggest_suprath_clusters(:,h), 95);
    
    % Delete the clusters in the map of observed statistical values that
    % are below the cluster threshold
    CC.PixelIdxList = CC.PixelIdxList(~(cluster_masses < ClusterThreshold));
    CC.NumObjects = size(CC.PixelIdxList, 2);
    cluster_masses(cluster_masses < ClusterThreshold) = [];

    SignificantClusters(h).CC = CC; 
    SignificantClusters(h).cluster_masses = cluster_masses; 

end

% Plot the difference map of the two original spectrograms and overlay the
% significant cluster in red
[DatasetA_avg, cut_idx, N] = average_and_combine_segments(TableScalogram_CWT_norm_subset{1}, 'DM_PreYN');
[DatasetB_avg, cut_idx, N] = average_and_combine_segments(TableScalogram_CWT_norm_subset{2}, 'DM_PreYN');

Difference_spectrogram = DatasetB_avg - DatasetA_avg;


for h = 1:nHemispheres

    mask_all_significant = false(size(Difference_spectrogram(:,:,h)));

    for i = 1:SignificantClusters(h).CC.NumObjects
        mask_all_significant(SignificantClusters(h).CC.PixelIdxList{i}) = true;
    end

    figure
    imagesc(DatasetA_avg(:,:,h))
    % colormap(winter)
    colorbar
    caxis([-0.9 1.2])
    
    figure
    imagesc(DatasetB_avg(:,:,h))
    % colormap(winter)
    colorbar
    caxis([-0.9 1.2])
    
    % figure
    % imagesc(Difference_spectrogram(:,:,h));  % your full unthresholded spectrogram
    % colormap(winter)
    % colorbar
    % caxis([-0.9 1.2])

    figure
    imagesc(Difference_spectrogram(:,:,h));
    % colormap(winter)
    colorbar
    caxis([-0.9 1.2])
    hold on;
    
    % 2. Get borders
    boundaries = bwboundaries(mask_all_significant);
    
    % 3. Plot borders
    for k = 1:length(boundaries)
        b = boundaries{k};
        plot(b(:,2), b(:,1), 'r', 'LineWidth', 2);  % Plot in red
    end

end


figure
imagesc(ThresholdMap(:,:,2)) 
colorbar





% [signal_to_plot, cut_idx, N] = average_and_combine_segments(TableScalogram_CWT_norm_TW, Labels_ColumnToAverage);
% % Labels_Plot = {'DMade-0.4s' 'DMade' 'DM+1s'};
% % Labels_Plot = {'StartDM' 'DMade' 'DMade+1s'};
% Labels_Plot = {'StartDM' 'StartDM+0.4s' };
% 
% params.frequencies = full_scalogram_CWT{1}.frequencies;
% plot_scalogram(signal_to_plot, cut_idx, LFP_run, params, Labels_Plot, N)
% 
% 
% 
% 
% 
% 
% % Step 3: Calculate p-values by comparing the observed stats to the permutation stats
% pValues = zeros(freqIdx, timeIdx, nHemispheres);  % Store p-values
% for f = 1:freqIdx
%     for t = 1:timeIdx
%         for h = 1:nHemispheres
%             % Calculate the p-value: the proportion of permutation stats that are as extreme or more extreme
%             pValues(f, t, h) = mean(abs(permStats(:, f, t, h)) >= abs(obsStats(f, t, h)));
%         end
%     end
% end
% 
% % Display or visualize p-values (for example, for one hemisphere and frequency range)
% figure
% imagesc(pValues(:,:,2));  % Display p-values for the left hemisphere (h = 1)
% colorbar;
% title('Permutation Test p-values (Right Hemisphere)');
% 
% pValues_significant = pValues < 0.05;
% figure
% imagesc(pValues_significant(:,:,2));  % Display p-values for the left hemisphere (h = 1)
% colorbar;
% title('Permutation Test p-values (Right Hemisphere)');


%%
DatasetA = TableScalogram_CWT_norm_subset_concurrentBurst.DM_PreYN;
DatasetB = TableScalogram_CWT_norm_subset_wo_concurrentBurst.DM_PreYN;
% DatasetB = DatasetA;
All_Datasets = vertcat(DatasetA, DatasetB);

% Example setup
nTrialsA = size(DatasetA,1);  % Number of trials in Condition A
nTrialsB = size(DatasetB,1);  % Number of trials in Condition B
nPermutations = 1000;  % Number of permutations for the test
freqIdx = size(DatasetA{1}, 1);  % Frequency bins
timeIdx = size(DatasetA{1}, 2);  % Time points
nHemispheres = size(DatasetA{1}, 3);  % Two hemispheres: left and right

% Initialize observed statistics and permutation stats containers
obsStats = zeros(freqIdx, timeIdx, nHemispheres);  % Observed test statistics (difference of means)
permStats = zeros(nPermutations, freqIdx, timeIdx, nHemispheres);  % Permutation distribution

% Loop over each frequency bin, time point, and hemisphere
for h = 1:nHemispheres
    for f = 1:freqIdx
        for t = 1:timeIdx
            % Extract all data for the given frequency, time, and hemisphere --> one pixel!
            allData = [];
            for i = 1:nTrialsA + nTrialsB
                allData = [allData; All_Datasets{i}(f, t, h)];  % Collect data from both conditions
            end

            % Step 1: Calculate the observed test statistic (difference of means)
            dataA = allData(1:nTrialsA);  % Data from Condition A (first 32 trials)
            dataB = allData(nTrialsA+1:end);  % Data from Condition B (next 96 trials)
            obsStats(f, t, h) = mean(dataA) - mean(dataB);

            % Step 2: Generate permutation statistics
            for perm = 1:nPermutations
                % Shuffle the combined data and randomly assign trials to both conditions
                shuffledData = allData(randperm(length(allData)));  % Shuffle the data randomly

                % Split the shuffled data into two new conditions, with the original sizes
                newDataA = shuffledData(1:nTrialsA);  % New Condition A after shuffle
                newDataB = shuffledData(nTrialsA+1:end);  % New Condition B after shuffle

                % Calculate the test statistic for the permuted data
                permStats(perm, f, t, h) = mean(newDataA) - mean(newDataB);
            end
        end
    end
end

% Step 3: Calculate p-values by comparing the observed stats to the permutation stats
pValues = zeros(freqIdx, timeIdx, nHemispheres);  % Store p-values
for f = 1:freqIdx
    for t = 1:timeIdx
        for h = 1:nHemispheres
            % Calculate the p-value: the proportion of permutation stats that are as extreme or more extreme
            pValues(f, t, h) = mean(abs(permStats(:, f, t, h)) >= abs(obsStats(f, t, h)));
        end
    end
end

% Display or visualize p-values (for example, for one hemisphere and frequency range)
figure
imagesc(pValues(:,:,2));  % Display p-values for the left hemisphere (h = 1)
colorbar;
title('Permutation Test p-values (Right Hemisphere)');

pValues_significant = pValues < 0.05;
figure
imagesc(pValues_significant(:,:,2));  % Display p-values for the left hemisphere (h = 1)
colorbar;
title('Permutation Test p-values (Right Hemisphere)');


%%

% Example of checking normality for spectrogram data

% Set up the data (assuming All_Datasets contains spectrogram data)
% All_Datasets is a 2D cell array where each cell contains a 3D matrix for trials
nTrialsA = size(DatasetA, 1); % Number of trials in Condition A
nTrialsB = size(DatasetB, 1); % Number of trials in Condition B
nTrials = nTrialsA + nTrialsB;  % Total number of trials

freqIdx = size(DatasetA{1}, 1); % Number of frequency bins
timeIdx = size(DatasetA{1}, 2); % Number of time points
nHemispheres = size(DatasetA{1}, 3); % Two hemispheres: left and right

Results = NaN(freqIdx, timeIdx, nHemispheres);
% Loop through each frequency-time pair to check normality
for f = 1:freqIdx
    for t = 1:timeIdx
        for h = 1:nHemispheres
            % Extract data for this frequency-time-bin across all trials
            allData = [];
            for trial = 1:nTrials
                allData = [allData; All_Datasets{trial}(f, t, h)];  % Collect data from both conditions
            end

            % Alternatively, you can use the Kolmogorov-Smirnov test (kstest)
            [h_ks, p_ks] = kstest((allData - mean(allData)) / std(allData));  % Normalized KS test
            % disp(['Kolmogorov-Smirnov test p-value for freq ', num2str(f), ', time ', num2str(t), ', hemisphere ', num2str(h), ': ', num2str(p_ks)]);
   
            % Optionally, you can store the results for further analysis
            if p_ks < 0.05
                % disp(['Data is NOT normally distributed at freq ', num2str(f), ', time ', num2str(t), ', hemisphere ', num2str(h)]);
                Results(f,t,h) = 0;
            else
                Results(f,t,h) = 1; %normally distributed
            end
        end
    end
end

figure
imagesc(Results(:,:,2));  %left hem
colorbar;




%% FIELDTRIP SHIT
trial_cells = TableScalogram_CWT_norm_subset_wo_concurrentBurst.DM_PreYN;

nTrials = numel(trial_cells);
[R, C, H] = size(trial_cells{2});  % R: time, C: freq, H: hemisphere

ft_data = [];
ft_data.label = {'Left', 'Right'};
ft_data.time = 1:size(trial_cells{1},2);
ft_data.freq = full_scalogram_CWT{1}.frequencies;
ft_data.dimord = 'rpt_chan_freq_time';
ft_data.powspctrm = zeros(nTrials, H, C, R);  % trials × chan × freq × time

for i = 1:nTrials
    trial = trial_cells{i};  % R × C × H
    trial_perm = permute(trial, [3 2 1]);  % H × freq × time
    ft_data.powspctrm(i,:,:,:) = trial_perm;
end

ft_condB = ft_data;


cfg = [];
cfg.trialfun                = 'ft_trialfun_general'; % this is the default
cfg.trialdef.eventvalue     = [1 2]; % the values of the stimulus trigger for the three conditions 

cfg = ft_definetrial(cfg);



% avg_data.label = avg_data.label{1};
% avg_data.powspctrm = avg_data.powspctrm(1,:,:);

cfg.channel = 'Left';  % or 'Right'
cfg.baseline = 'no';  % skip for now, or use [start end] baseline window
cfg.zlim = 'maxabs';  % or e.g. [0 10]
cfg.showlabels = 'yes';

layout.label = {'Left', 'Right'};  % Channel labels
layout.pos = [0.25 0.5; 0.75 0.5];  % X,Y positions for plotting each channel
layout.width = [0.2 0.2];  % Width of the plotting area for each channel
layout.height = [0.2 0.2];  % Height of the plotting area for each channel
layout.mask = {};  % Empty mask (FieldTrip will handle it automatically)
layout.label = {'Left'};
cfg.layout = layout;

ft_multiplotTFR(cfg, avg_data); % the plot is the same


%% Behavioral analysis

behav_analysis_acceptance_and_DT(TableBehavSubset)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% GroupList = {'B1&B4', 'B2&B3', 'B5&B6'};
GroupList = {'B1', 'B2', 'B3', 'B4'};

SingleDTs = {};
SingleAcceptance = {};
MeanDT = NaN(size(GroupList,2), 2);
StdDT = NaN(size(GroupList,2), 2);
MeanAcc = NaN(size(GroupList,2), 2);
StdAcc = NaN(size(GroupList,2), 2);



for b=1:length(GroupList)

    TableBehavCondition = table('Size', [1 size(All_TableBehavior, 2)], ...
                     'VariableTypes', repmat({'cell'}, 1, size(All_TableBehavior,2)), ...
                     'VariableNames', All_TableBehavior.Properties.VariableNames);
    % TableBehavCondition.Effort = {[0.45 0.6; 0.75 0.9]}; % 'B5&B6'
%     TableBehavCondition.Reward = {[1 5]}; % 'B5&B6'
    TableBehavCondition.Effort = {[0.45 0.6; 0.75 0.9]}; % 'B5&B6'

    TableBehavCondition.Block = GroupList(b); % 'B5&B6'
    [~, TableBehavSubset] = get_subset_based_on_behavior(All_TableScalogram_CWT_norm, All_TableBehavior, TableBehavCondition);

    for t = 1:size(TableBehavSubset,2)

        SingleDTs = TableBehavSubset{:,t}.DecisionTime;
    
        MeanDT(b, t) = mean(SingleDTs);
        StdDT(b, t) = std(SingleDTs)/sqrt(numel(SingleDTs));
    
        SingleAcceptance = TableBehavSubset{:,t}.Acceptance;
    
        MeanAcc(b, t) = mean(SingleAcceptance);
        StdAcc(b, t) = std(SingleAcceptance)/sqrt(numel(SingleAcceptance));

    end

end

figure
e = errorbar(MeanDT, StdDT, '.', 'MarkerSize', 30);
e.CapSize = 0;
xlim([0 numel(MeanDT)+1])
ylim([0.5 1])
xticks([1:numel(MeanDT)])
xticklabels({'HF', 'iTBS', 'cTBS'})
% xticklabels({'HF', 'iTBS', 'iTBS', 'HF', 'cTBS', 'cTBS'})
ylabel('Decision Time (s)')
xlabel('Stim Cond')
box off

figure
e = errorbar(MeanAcc, StdAcc, '.', 'MarkerSize', 30);
e.CapSize = 0;
xlim([0 numel(MeanDT)+1])
ylim([0.4 1])
xticks([1:numel(MeanDT)])
xticklabels({'HF', 'iTBS', 'cTBS'})
% xticklabels({'HF', 'iTBS', 'iTBS', 'HF', 'cTBS', 'cTBS'})
ylabel('Acceptance')
xlabel('Stim Cond')
box off





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% OVERSHOOT
BlocksList = unique(TableBehavSubset.Block);
MeanOvershoot = NaN(size(BlocksList));
StdOvershoot = NaN(size(BlocksList));

for b=1:length(BlocksList)

    Subset = TableBehavSubset(strcmp(TableBehavSubset.Block, BlocksList(b)), :);
    SingleOvershoots = (cellfun(@(x) x(end), Subset.CURSOR) - Subset.EffortTested) * 100;
    SingleOvershoots(isnan(SingleOvershoots)) = [];

    MeanOvershoot(b) = mean(SingleOvershoots);
    StdOvershoot(b) = std(SingleOvershoots);

end

figure
e = errorbar(MeanOvershoot, StdOvershoot/numel(StdOvershoot), '.', 'MarkerSize', 30);
e.CapSize = 0;
xlim([0 7])
xticks([1 2 3 4 5 6])
xticklabels({'HF', 'iTBS', 'iTBS', 'HF', 'cTBS', 'cTBS'})
ylabel('Overshoot (%MTF)')
xlabel('Blocks')
box off


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECISION TIME


GroupList = {'B1&B4', 'B2&B3', 'B5&B6'};
% GroupList = {'B1', 'B2', 'B3', 'B4', 'B5', 'B6'};

SingleDTs = {};
SingleAcceptance = {};
MeanDT = NaN(size(GroupList));
StdDT = NaN(size(GroupList));
MeanAcc = NaN(size(GroupList));
StdAcc = NaN(size(GroupList));



for b=1:length(GroupList)

    TableBehavCondition = table('Size', [1 size(All_TableBehavior, 2)], ...
                     'VariableTypes', repmat({'cell'}, 1, size(All_TableBehavior,2)), ...
                     'VariableNames', All_TableBehavior.Properties.VariableNames);
    % TableBehavCondition.Effort = {[0.45 0.6; 0.75 0.9]}; % 'B5&B6'
%     TableBehavCondition.Reward = {[1 5]}; % 'B5&B6'
%     TableBehavCondition.Effort = {[0.45 0.6]}; % 'B5&B6'

    TableBehavCondition.Block = GroupList(b); % 'B5&B6'
    [~, TableBehavSubset] = get_subset_based_on_behavior(All_TableScalogram_CWT_norm, All_TableBehavior, TableBehavCondition);
%     TableBehavSubset = TableBehavSubset{1};
%     TableBehavSubset(TableBehavSubset.Reward == 10, :) = [];
%     TableBehavSubset(TableBehavSubset.Reward == 20, :) = [];
%     TableBehavSubset(TableBehavSubset.Effort == 0.45, :) = [];
%     TableBehavSubset(TableBehavSubset.Effort == 0.60, :) = [];
    % TableBehavSubset = TableBehavSubset{2};

    SingleDTs{b} = TableBehavSubset.DecisionTime;

    MeanDT(b) = mean(SingleDTs{b});
    StdDT(b) = std(SingleDTs{b})/sqrt(numel(SingleDTs{b}));

    SingleAcceptance{b} = TableBehavSubset.Acceptance;

    MeanAcc(b) = mean(SingleAcceptance{b});
    StdAcc(b) = std(SingleAcceptance{b})/sqrt(numel(SingleAcceptance{b}));

end

figure
e = errorbar(MeanDT, StdDT, '.', 'MarkerSize', 30);
e.CapSize = 0;
xlim([0 numel(MeanDT)+1])
ylim([0.5 1])
xticks([1:numel(MeanDT)])
xticklabels({'HF', 'iTBS', 'cTBS'})
% xticklabels({'HF', 'iTBS', 'iTBS', 'HF', 'cTBS', 'cTBS'})
ylabel('Decision Time (s)')
xlabel('Stim Cond')
box off

figure
e = errorbar(MeanAcc, StdAcc, '.', 'MarkerSize', 30);
e.CapSize = 0;
xlim([0 numel(MeanDT)+1])
ylim([0.4 1])
xticks([1:numel(MeanDT)])
xticklabels({'HF', 'iTBS', 'cTBS'})
% xticklabels({'HF', 'iTBS', 'iTBS', 'HF', 'cTBS', 'cTBS'})
ylabel('Acceptance')
xlabel('Stim Cond')
box off

%% CWT - averaging and plotting specific frequency bands

NameBehavCondition = {'Low Eff', 'High Eff'};
TableBehavCondition = table('Size', [1 size(All_TableBehavior, 2)], ...
                     'VariableTypes', repmat({'cell'}, 1, size(All_TableBehavior,2)), ...
                     'VariableNames', All_TableBehavior.Properties.VariableNames);
% TableBehavCondition.Effort = {[0.5 0.65; 0.8 0.95]}; % Split low and high efforts
TableBehavCondition.Effort = {[0.45 0.60; 0.75 0.90]}; % Split low and high efforts
TableBehavCondition.Block = {'B5'}; % 'B5&B6'

% TableBehavCondition.Reward = {[1 5; 10 20]}; % Split low and high rewards
% TableBehavCondition.Acceptance = {[0; 1]}; % Split low and high efforts
% TableBehavCondition.Acceptance = {[0; 1]}; % Split low and high efforts
% TableBehavCondition.Acceptance = {0}; % if only one condition, it will be applied to the whole dataset!

[TableScalogram_CWT_norm_subset, TableBehavSubset] = get_subset_based_on_behavior(All_TableScalogram_CWT_norm, All_TableBehavior, TableBehavCondition);


FrequencyLimits = [3 6]; %; 8 12; 12 30; 30 100];
FrequencyLabels = {'Theta'}; %, 'Alpha', 'Beta', 'Gamma'};


[TablePSD_mean_SE_cond1, TablePSD_band_single_trial_cond1] = compute_band_average_power(TableScalogram_CWT_norm_subset{1}, FrequencyLimits, FrequencyLabels, full_scalogram_CWT{1}.frequencies);
   
[TablePSD_mean_SE_cond2, TablePSD_band_single_trial_cond2] = compute_band_average_power(TableScalogram_CWT_norm_subset{2}, FrequencyLimits, FrequencyLabels, full_scalogram_CWT{1}.frequencies);

% NamePhasesOfInterest = {'DM_PreYN', 'DM_PostYN'};
% NamePhasesOfInterest = {'PrepEP'};
NamePhasesOfInterest = {'DM_PreYN'};
% NamePhasesOfInterest = {'DM_PreYN', 'DM_PostYN'};

plot_band_average_power({TablePSD_mean_SE_cond1, TablePSD_mean_SE_cond2}, NameBehavCondition, NamePhasesOfInterest, {TablePSD_band_single_trial_cond1, TablePSD_band_single_trial_cond2})


%% PSD averaging specific frequency bands

% FrequencyLimits = [4 8; 8 12; 12 20; 20 30; 30 100];
% FrequencyLabels = {'Theta', 'Alpha', 'LowBeta', 'HighBeta', 'Gamma'};

FrequencyLimits = [4 8; 8 12; 12 30; 30 100];
FrequencyLabels = {'Theta', 'Alpha', 'Beta', 'Gamma'};



[TablePSD_mean_SE, TablePSD_band_single_trial] = compute_band_average_power(TablePSD_norm, FrequencyLimits, FrequencyLabels);

[TableFourier_mean_SE, TableFourier_band_single_trial] = compute_band_average_power(TableFourier_norm, FrequencyLimits, FrequencyLabels);

[TableSpectrum_CWT_mean_SE, TableSpectrum_CWT_band_single_trial] = compute_band_average_power(TableSpectrum_CWT_norm, FrequencyLimits, FrequencyLabels, full_spectrum_CWT{1}.frequencies);

%% Plot Power

% Plot first trial, first phase spectrum
phase_idx = 1;
trial_idx = 1;
sig = flip(mean(TableSpectrum_CWT{trial_idx,phase_idx}{:}(:,:,1),2));
f = flip(full_spectrum_CWT{1, 1}.frequencies);
figure
subplot(2,3,1)
plot(f, sig)
title('CWT')

% Plot averaged spectrum across trials, first phase
y = cellfun(@(x) x(:,:,1), TableSpectrum_CWT{:,phase_idx}, 'UniformOutput', false);
y = cellfun(@(x) mean(x, 2), y, 'UniformOutput', false);
average_y = mean(cell2mat(y'), 2);
f = full_spectrum_CWT{1, 1}.frequencies;
subplot(2,3,4)
plot(f, average_y)
title('CWT averaged')

% Plot first trial, first phase PSD
subplot(2,3,2)
plot(TablePSD{1,phase_idx}{:}(:,3), TablePSD{trial_idx,phase_idx}{:}(:,1))
title('Welch')

% Plot averaged spectrum across trials, first phase
y = cellfun(@(x) x(:,1), TablePSD{:,phase_idx}, 'UniformOutput', false);
average_y = mean(cell2mat(y'), 2);
f = TablePSD{1,phase_idx}{:}(:,3);
subplot(2,3,5)
plot(f, average_y)
title('Welch averaged')

% Plot first trial, first phase spectrum
subplot(2,3,3)
plot(TableFourier{1,phase_idx}{:}(:,3), TableFourier{trial_idx,phase_idx}{:}(:,1))
title('Fourier')


% Plot averaged spectrum across trials, first phase
y = cellfun(@(x) x(:,1), TableFourier{:,phase_idx}, 'UniformOutput', false);
average_y = mean(cell2mat(y'), 2);
f = TableFourier{1,phase_idx}{:}(:,3);
subplot(2,3,6)
plot(f, average_y)
title('Fourier averaged')




%% Restructuring for R

% Does beta power depend on single-trial effort? --> Isolate only beta 
% Hoy takes from 0.5 to 1.5s post-offer (1.5 because until then they do not 
% show motor mappings for the choice! but in our case for now I will consider 
% the whole phase from offer presentation to decision made)

% Get the data and add it to the behavioral table
R_table_Beta_DM_PreYN = All_TableBehavior;
R_table_Beta_DM_PreYN.Beta_DM_PreYN_L = TableFourier_band_single_trial{"Beta", "DM_PreYN"}{:}(:,1);
R_table_Beta_DM_PreYN.Beta_DM_PreYN_R = TableFourier_band_single_trial{"Beta", "DM_PreYN"}{:}(:,2);
R_table_Beta_DM_PreYN.Theta_DM_PreYN_L = TableFourier_band_single_trial{"Theta", "DM_PreYN"}{:}(:,1);
R_table_Beta_DM_PreYN.Theta_DM_PreYN_R = TableFourier_band_single_trial{"Theta", "DM_PreYN"}{:}(:,2);
R_table_Beta_DM_PreYN.Gamma_DM_PreYN_L = TableFourier_band_single_trial{"Gamma", "DM_PreYN"}{:}(:,1);
R_table_Beta_DM_PreYN.Gamma_DM_PreYN_R = TableFourier_band_single_trial{"Gamma", "DM_PreYN"}{:}(:,2);

% Get the data and add it to the behavioral table
R_Subj_CWT_DM_PreYN = All_TableBehavior;
R_Subj_CWT_DM_PreYN.Theta_DM_PreYN_L = TableSpectrum_CWT_band_single_trial{"Theta", "DM_PreYN"}{:}(:,1);
R_Subj_CWT_DM_PreYN.Theta_DM_PreYN_R = TableSpectrum_CWT_band_single_trial{"Theta", "DM_PreYN"}{:}(:,2);
R_Subj_CWT_DM_PreYN.Alpha_DM_PreYN_L = TableSpectrum_CWT_band_single_trial{"Alpha", "DM_PreYN"}{:}(:,1);
R_Subj_CWT_DM_PreYN.Alpha_DM_PreYN_R = TableSpectrum_CWT_band_single_trial{"Alpha", "DM_PreYN"}{:}(:,2);
% R_Subj_CWT_DM_PreYN.LowBeta_DM_PreYN_L = TableSpectrum_CWT_band_single_trial{"LowBeta", "DM_PreYN"}{:}(:,1);
% R_Subj_CWT_DM_PreYN.LowBeta_DM_PreYN_R = TableSpectrum_CWT_band_single_trial{"LowBeta", "DM_PreYN"}{:}(:,2);
% R_Subj_CWT_DM_PreYN.HighBeta_DM_PreYN_L = TableSpectrum_CWT_band_single_trial{"HighBeta", "DM_PreYN"}{:}(:,1);
% R_Subj_CWT_DM_PreYN.HighBeta_DM_PreYN_R = TableSpectrum_CWT_band_single_trial{"HighBeta", "DM_PreYN"}{:}(:,2);
R_Subj_CWT_DM_PreYN.Beta_DM_PreYN_L = TableSpectrum_CWT_band_single_trial{"Beta", "DM_PreYN"}{:}(:,1);
R_Subj_CWT_DM_PreYN.Beta_DM_PreYN_R = TableSpectrum_CWT_band_single_trial{"Beta", "DM_PreYN"}{:}(:,2);
R_Subj_CWT_DM_PreYN.Gamma_DM_PreYN_L = TableSpectrum_CWT_band_single_trial{"Gamma", "DM_PreYN"}{:}(:,1);
R_Subj_CWT_DM_PreYN.Gamma_DM_PreYN_R = TableSpectrum_CWT_band_single_trial{"Gamma", "DM_PreYN"}{:}(:,2);



writetable(R_Subj_CWT_DM_PreYN, 'R_Sub1_AM_PM_exported20250120_v1.xlsx');



%% PSD Welch - averaging and plotting specific frequency bands


FrequencyLimits = [4 8; 8 12; 12 30; 30 100];
FrequencyLabels = {'Theta', 'Alpha', 'Beta', 'Gamma'};



[TablePSD_mean_SE_cond1, TablePSD_band_single_trial_cond1] = compute_band_average_power(TablePSD_norm_subset{1}, FrequencyLimits, FrequencyLabels);

[TablePSD_mean_SE_cond2, TablePSD_band_single_trial_cond2] = compute_band_average_power(TablePSD_norm_subset{2}, FrequencyLimits, FrequencyLabels);

% NamePhasesOfInterest = {'DM_PreYN', 'DM_PostYN', 'PrepEP'};
NamePhasesOfInterest = {'EP'};

plot_band_average_power({TablePSD_mean_SE_cond1, TablePSD_mean_SE_cond2}, NameBehavCondition, NamePhasesOfInterest, {TablePSD_band_single_trial_cond1, TablePSD_band_single_trial_cond2})




%% Fourier - averaging and plotting specific frequency bands

[TablePSD_mean_SE_cond1, TablePSD_band_single_trial_cond1] = compute_band_average_power(TableFourier_norm_subset{1}, FrequencyLimits, FrequencyLabels, full_spectrum_CWT{1}.frequencies);

[TablePSD_mean_SE_cond2, TablePSD_band_single_trial_cond2] = compute_band_average_power(TableFourier_norm_subset{2}, FrequencyLimits, FrequencyLabels, full_spectrum_CWT{1}.frequencies);

NamePhasesOfInterest = {'EP'};

plot_band_average_power({TablePSD_mean_SE_cond1, TablePSD_mean_SE_cond2}, NameBehavCondition, NamePhasesOfInterest, {TablePSD_band_single_trial_cond1, TablePSD_band_single_trial_cond2})


%% Plots PSD mean and SE



%% % Get handles of all open figures
figures = findobj('Type', 'figure');

% Loop over all figures and save them
for i = 1:length(figures)
    % Create a filename based on the figure number
    filename = sprintf('figure_%d.jpg', i);  % Change format if needed (.jpg, .pdf, etc.)
    
    % Save the figure
    saveas(figures(i), filename);
end


%% PD_TI
TI = TI_info{1};
LFP_cut = LFP_run{1};

% PLOT RAW LFP
figure
tiledlayout(2,1,"TileSpacing","tight")
nexttile
plot(LFP_cut.time, LFP_cut.data(:,1))
xlim([0 1000])
ylim([-100 100])
hold on
xline(TI.TI_trig_LFP_referred/LFP_cut.Fs, 'b--')
title('Raw LFP - Left hemisphere')
nexttile
plot(LFP_cut.time, LFP_cut.data(:,2))
xlim([0 1000])
ylim([-100 100])
title('Raw LFP - Right hemisphere')
linkaxes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CUT BEFORE THE TI TRIGGER
TI = TI_info{1};
LFP_cut = LFP_run{1};
LFP_cut.data = LFP_cut.data(40*LFP_cut.Fs : TI.TI_trig_LFP_referred-1, :); 
LFP_cut.time = 1/LFP_cut.Fs : 1/LFP_cut.Fs : size(LFP_cut.data, 1)/LFP_cut.Fs;


% PLOT RAW LFP
figure
tiledlayout(2,1,"TileSpacing","tight")
nexttile
plot(LFP_cut.time, LFP_cut.data(:,1))
xlim([0 1000])
ylim([-100 100])
hold on
xline(TI.TI_trig_LFP_referred/LFP_cut.Fs, 'b--')
title('Raw LFP before TI - Left hemisphere')
nexttile
plot(LFP_cut.time, LFP_cut.data(:,2))
xlim([0 1000])
ylim([-100 100])
title('Raw LFP before TI onset - Right hemisphere')
linkaxes

figure
COMPats_PERCEPT_plot_BS(LFP_cut,[],0,1)


% PLOT FFT 
T = 1/LFP_cut.Fs;             % Sampling period       
L = fix(size(LFP_cut.data, 1))-1;             % Length of signal
t = (0:L-1)*T;        % Time vector

Y_left = fft(LFP_cut.data(:,2));
P2_left = abs(Y_left/L);
P1_left = P2_left(1:L/2+1);
P1_left(2:end-1) = 2*P1_left(2:end-1);
f = LFP_cut.Fs*(0:(L/2))/L;
figure
tiledlayout(2,1,"TileSpacing","compact")
nexttile
plot(f,P1_left) 
ylim([0 1.5])
hold on
title("RIGHT Hem before TI onset")
xlabel("f (Hz)")
ylabel("|P1(f)|") 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CUT AFTER THE TI TRIGGER

TI = TI_info{1};
LFP_cut = LFP_run{1};
LFP_cut.data = LFP_cut.data(TI.TI_trig_LFP_referred : end-20*LFP_cut.Fs, :);
LFP_cut.time = 1/LFP_cut.Fs : 1/LFP_cut.Fs : size(LFP_cut.data, 1)/LFP_cut.Fs;

T = 1/LFP_cut.Fs;             % Sampling period       
L = fix(size(LFP_cut.data, 1))-1;             % Length of signal
t = (0:L-1)*T;        % Time vector

% nexttile
hold on
Y_left = fft(LFP_cut.data(:,2));
P2_left = abs(Y_left/L);
P1_left = P2_left(1:L/2+1);
P1_left(2:end-1) = 2*P1_left(2:end-1);
f = LFP_cut.Fs*(0:(L/2))/L;
plot(f,P1_left, 'r') 
ylim([0 1.5])
hold on
title("RIGHT Hem after TI onset")
xlabel("f (Hz)")
ylabel("|P1(f)|") 

% PLOT RAW LFP
figure
tiledlayout(2,1,"TileSpacing","tight")
nexttile
plot(LFP_cut.time, LFP_cut.data(:,1), 'r')
xlim([0 1000])
ylim([-100 100])
hold on
xline(TI.TI_trig_LFP_referred/LFP_cut.Fs, 'b--')
title('Raw LFP after TI onset - Left hemisphere')
nexttile
plot(LFP_cut.time, LFP_cut.data(:,2), 'r')
xlim([0 1000])
ylim([-100 100])
title('Raw LFP after TI onset - Right hemisphere')
linkaxes

figure
COMPats_PERCEPT_plot_BS(LFP_cut,[],0,1)



%%
close all

Ramp = repelem(0, (5*LFP_run{r}.Fs) + 1);
Train2s = repmat([repelem(1, round(0.03*LFP_run{r}.Fs)) repelem(0, fix((0.2-0.03)*LFP_run{r}.Fs))], 1, 10);
Break8s = repelem(0, 8*LFP_run{r}.Fs);
iTBS_sequence = [Ramp repmat([Train2s Break8s], 1, 52)];
cTBS_sequence = [Ramp repmat(Train2s, 1, 520/2)];

%%%%%%% SET TIME
TimeStart = 1; 
TimeEnd = 250; %s

LFP_cut = LFP_run{1};
LFP_cut.data = LFP_cut.data(TimeStart*LFP_run{r}.Fs : 1*TimeEnd*LFP_run{r}.Fs, :);
LFP_cut.time = 1/LFP_cut.Fs : 1/LFP_cut.Fs : size(LFP_cut.data, 1)/LFP_cut.Fs;

TI = TI_info{1};
TI.TI_trig_LFP_referred = TI.TI_trig_LFP_referred - TimeStart*LFP_run{r}.Fs;


% PLOT RAW LFP
figure
tiledlayout(2,1,"TileSpacing","tight")
nexttile
plot(LFP_cut.data(:,1), 'r')
ylim([-100 100])
hold on
xline(TI.TI_trig_LFP_referred, 'b--')
TIsequence_alignedToTrigger = [zeros(1, TI.TI_trig_LFP_referred + 1) iTBS_sequence];
TIsequence_alignedToTrigger = TIsequence_alignedToTrigger(1:1*(TimeEnd-TimeStart)*LFP_run{r}.Fs);
plot((TIsequence_alignedToTrigger*120)-60)



% Template subtraction

Onsets = find(diff([0 TIsequence_alignedToTrigger]) == 1) - 1; % -1 to find the LAST zero before the artifact!
End = find(diff([TIsequence_alignedToTrigger 0 ]) == -1) + 1;

xline(Onsets, 'g')
xline(End, 'r')

Templates_L_hemisphere = [];
Templates_R_hemisphere = [];
figure
for i=1:length(Onsets)
    % Isolate the template
    Templates_L_hemisphere(i,:) = LFP_cut.data(Onsets(i):End(i), 1); 
    Templates_R_hemisphere(i,:) = LFP_cut.data(Onsets(i):End(i), 1); 

    plot(Templates_L_hemisphere(i,:))
    hold on
end


AvgTemplate_L_hemisphere = mean(Templates_L_hemisphere, 1);
plot(AvgTemplate_L_hemisphere, 'k', 'LineWidth', 2)

legend('1', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Avg')


figure
COMPats_PERCEPT_plot_BS(LFP_cut,[],0,1)


T = 1/LFP_cut.Fs;             % Sampling period       
L = fix(size(LFP_cut.data, 1))-1;             % Length of signal
t = (0:L-1)*T;        % Time vector

figure
% nexttile
Y_left = fft(LFP_cut.data(:,1));
P2_left = abs(Y_left/L);
P1_left = P2_left(1:L/2+1);
P1_left(2:end-1) = 2*P1_left(2:end-1);
f = LFP_cut.Fs*(0:(L/2))/L;
plot(f,P1_left, 'r') 
ylim([0 2])
hold on
title("LEFT Hem")
xlabel("f (Hz)")
ylabel("|P1(f)|") 

% % Subtract the template
% LFP_filt = LFP_cut;
% 
% for i=1:length(Onsets)
%         LFP_filt.data(Onsets(i):End(i), 1) = LFP_filt.data(Onsets(i):End(i), 1) .* zeros(length(LFP_filt.data(Onsets(i):End(i), 1)),1); % THIS WORKS
%         % LFP_filt.data(Onsets(i):End(i), 1) = LFP_filt.data(Onsets(i):End(i), 1) - AvgTemplate_L_hemisphere'; % this might work with the right template?
%         % LFP_filt.data(Onsets(i):End(i), 1) = LFP_filt.data(Onsets(i):End(i), 1) * 0.05; % THIS WORKS
% 
%     hold on
% end

% Subtract the template
LFP_filt = LFP_cut;

for i=1:length(Onsets)

        SignalDuringArtifact = LFP_filt.data(Onsets(i) : End(i), 1);
        MeanDuringArtifact = mean(SignalDuringArtifact);
        MaxDuringArtifact = max(SignalDuringArtifact);   
        MinDuringArtifact = min(SignalDuringArtifact);
        p2pDuringArtifact = MaxDuringArtifact - MinDuringArtifact;
        
        % SignalBeforeArtifact = LFP_filt.data(Onsets(i)-0.1*LFP_filt.Fs : Onsets(i)-1, 1);
        SignalBeforeArtifact = LFP_filt.data(Onsets(i)-length(SignalDuringArtifact) : Onsets(i)-1, 1);

        MeanBeforeArtifact = mean(SignalBeforeArtifact);
        MaxBeforeArtifact = max(SignalBeforeArtifact);   
        MinBeforeArtifact = min(SignalBeforeArtifact);
        p2pBeforeArtifact = MaxBeforeArtifact - MinBeforeArtifact;

        % SignalAfterArtifact = LFP_filt.data(End(i)+1 : End(i)+0.1*LFP_filt.Fs, 1);
        SignalAfterArtifact = LFP_filt.data(End(i)+1: End(i)+length(SignalDuringArtifact), 1);

        MeanAfterArtifact = mean(SignalAfterArtifact);
        MaxAfterArtifact = max(SignalAfterArtifact);   
        MinAfterArtifact = min(SignalAfterArtifact);
        p2pAfterArtifact = MaxAfterArtifact - MinAfterArtifact;

        ReplacementSignal = (SignalBeforeArtifact + SignalAfterArtifact) / 2;

        % AvgTemplate_L_hemisphere
        scale = ((p2pBeforeArtifact+p2pAfterArtifact)/2) / p2pDuringArtifact;
        offset = ((MeanBeforeArtifact-MeanAfterArtifact)/2);

        % LFP_filt.data(Onsets(i):End(i), 1) = LFP_filt.data(Onsets(i):End(i), 1) * scale - offset; % THIS WORKS
        LFP_filt.data(Onsets(i):End(i), 1) = ReplacementSignal;

end

figure
COMPats_PERCEPT_plot_BS(LFP_filt,[],0,1)

T = 1/LFP_filt.Fs;             % Sampling period       
L = fix(size(LFP_filt.data, 1))-1;             % Length of signal
t = (0:L-1)*T;        % Time vector

figure
% nexttile
Y_left = fft(LFP_filt.data(:,1));
P2_left = abs(Y_left/L);
P1_left = P2_left(1:L/2+1);
P1_left(2:end-1) = 2*P1_left(2:end-1);
f = LFP_filt.Fs*(0:(L/2))/L;
plot(f,P1_left, 'k') 
ylim([0 2])
hold on
title("LEFT Hem")
xlabel("f (Hz)")
ylabel("|P1(f)|") 


LFP_filtfilt = LFP_filt;

for i=1:length(Onsets)

        margin = 3; 
        smoothing_degree = 2;
        smooth_range = (Onsets(i)-margin : Onsets(i)+margin);
        LFP_filtfilt.data(smooth_range, 1) = smoothdata(LFP_filtfilt.data(smooth_range, 1), 'movmean', smoothing_degree);

        smooth_range = (End(i)-margin : End(i)+margin);
        LFP_filtfilt.data(smooth_range, 1) = smoothdata(LFP_filtfilt.data(smooth_range, 1), 'movmean', smoothing_degree);

end


figure
plot(LFP_cut.data(:,1), 'b')
ylim([-100 100])
hold on
plot(LFP_filt.data(:,1), 'r')
plot(LFP_filtfilt.data(:,1), 'g')


xline(TI.TI_trig_LFP_referred, 'b--')
xline(Onsets, 'g')
xline(End, 'r')

figure
COMPats_PERCEPT_plot_BS(LFP_filtfilt,[],0,1)

T = 1/LFP_filtfilt.Fs;             % Sampling period       
L = fix(size(LFP_filtfilt.data, 1))-1;             % Length of signal
t = (0:L-1)*T;        % Time vector

figure
% nexttile
Y_left = fft(LFP_filtfilt.data(:,1));
P2_left = abs(Y_left/L);
P1_left = P2_left(1:L/2+1);
P1_left(2:end-1) = 2*P1_left(2:end-1);
f = LFP_filtfilt.Fs*(0:(L/2))/L;
plot(f,P1_left, 'b') 
ylim([0 2])
hold on
title("LEFT Hem")
xlabel("f (Hz)")
ylabel("|P1(f)|") 



% Average of all the 10s periods
breaks = find(diff(Onsets) > 1000);

Start2s = [Onsets(1), Onsets(breaks + 1)];
End8s = Start2s + 10*LFP_cut.Fs;

All_Trains = [];
for i=1:length(Start2s)-1
    All_Trains = [All_Trains LFP_filt.data(Start2s(i):End8s(i), 1)];
end

Average_Trains = mean(All_Trains, 2);

figure
plot(Average_Trains')

%% Instantaneous Power computed with hilbert transform

FrequencyLimits = [3 7; 7 12; 12 30; 30 80];
FrequencyLabels = {'Theta', 'Alpha', 'Beta', 'Gamma'};
NamePhasesOfInterest = {'FullSignal'};

[TablePower_mean_SE_subset1, TablePower_band_single_trial_subset1] = compute_band_average_power(TableInstantaneousPower_Hilbert_norm_subset{1}, FrequencyLimits, FrequencyLabels);

[TablePower_mean_SE_subset2, TablePower_band_single_trial_subset2] = compute_band_average_power(TableInstantaneousPower_Hilbert_norm_subset{2}, FrequencyLimits, FrequencyLabels);

plot_band_average_power({TablePower_mean_SE_subset1, TablePower_mean_SE_subset2}, NameBehavCondition, NamePhasesOfInterest, {TablePower_band_single_trial_subset1, TablePower_band_single_trial_subset2})

% For behavioral subsets
[TableSpectrogram_average_subset1, TableSpectrogram__SE_subset1, N1] = compute_band_average_spectrogram(TableInstantaneousPower_Hilbert_norm_subset{1}, FrequencyLimits, FrequencyLabels);
[TableSpectrogram_average_subset2, TableSpectrogram__SE_subset2, N2] = compute_band_average_spectrogram(TableInstantaneousPower_Hilbert_norm_subset{2}, FrequencyLimits, FrequencyLabels);

plot_band_average_spectrogram({TableSpectrogram_average_subset1, TableSpectrogram_average_subset2}, {TableSpectrogram__SE_subset1, TableSpectrogram__SE_subset2}, NameBehavCondition, NamePhasesOfInterest, [N1 N2])
